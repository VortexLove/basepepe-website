<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Dice - Pepe Blackjack Casino</title>
  <meta name="description" content="Play PBJ Dice in arcade style. Predict over / under / exact sum and win multipliers in this provably-fair style demo." />
  
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com" crossorigin />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet" />
  
  <style>
    :root {
      color-scheme: dark;
      scroll-behavior:smooth;
      --bg:#02040a;
      --panel:#0a1114;
      --panel-alt:#081014;
      --accent:#39ff14;
      --accent-soft:#39ff1490;
      --border:#123b27;
      --border-alt:#1e5a3c;
      --text:#e5fcef;
      --text-soft:#b8ffda;
      --muted:#86bfa6;
      --danger:#ff4e4e;
      --radius-sm:8px;
      --radius:16px;
      --radius-lg:22px;
      --shadow:0 0 0 3px #0d1e15 inset, 0 14px 30px rgba(0,0,0,.6), 0 0 42px #39ff1428;
    }
    html, body { margin:0; padding:0; background:radial-gradient(circle at 10% 0%, #071b12 0, #000 60%); }
    html, body, * { font-family:'Press Start 2P', cursive !important; }
    body { -webkit-font-smoothing:antialiased; text-rendering:optimizeLegibility; color:var(--text-soft); }
    img { max-width:100%; height:auto; display:block; }
    a { color:var(--accent); text-decoration:none; }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 40px 20px 120px;
    }

    .back-link {
      display:inline-flex;
      align-items:center;
      gap:6px;
      background:#0f2b1c;
      color:#a9ffcf;
      border:2px solid #1e5a3c;
      padding:10px 16px;
      border-radius:999px;
      text-decoration:none;
      font-size:11px;
      margin-bottom:30px;
      box-shadow:0 0 8px #39ff1433, 2px 2px 0 #001c0d;
      transition:transform .15s, box-shadow .15s, border-color .15s;
    }
    .back-link:hover {
      transform:translateY(-3px);
      box-shadow:0 0 14px var(--accent), 4px 4px 0 #001c0d;
      border-color:#22c55e;
    }

    h1 {
      color:var(--accent);
      text-shadow:0 0 14px var(--accent);
      font-size:26px;
      margin-bottom:26px;
      text-align:center;
    }

    .hero-section {
      background:radial-gradient(circle at 0 0,#0b151d 0,#02060c 60%);
      border-radius:var(--radius-lg);
      padding:28px 24px 30px;
      box-shadow:var(--shadow);
      border:1px solid var(--border);
      margin-bottom:40px;
      position:relative;
      overflow:hidden;
    }
    .hero-section::before {
      content:"";
      position:absolute;
      inset:-3px;
      border-radius:calc(var(--radius-lg) + 2px);
      z-index:-1;
      background:conic-gradient(from 0deg,#39ff14,#00ffa5,#39ff14);
      filter:blur(20px);
      opacity:.16;
      animation:spinGlow 16s linear infinite;
    }
    @keyframes spinGlow {
      0%{transform:rotate(0);}
      100%{transform:rotate(360deg);}
    }

    .hero-image {
      width:100%;
      border-radius:14px;
      border:2px solid #1e5a3c;
      box-shadow:inset 0 0 16px #0c2d20, 0 10px 30px #000000aa, 0 0 24px #39ff1422;
      margin-bottom:20px;
      background:radial-gradient(circle at 0 0,#062818 0,#020806 60%);
      min-height:160px;
      display:flex;
      align-items:center;
      justify-content:center;
      color:#bbf7d0;
      font-size:12px;
      padding:16px;
      text-align:center;
      position:relative;
      overflow:hidden;
    }
    .hero-image::after {
      content:"DEMO ONLY ‚Ä¢ NO REAL TOKENS";
      position:absolute;
      right:14px;
      bottom:12px;
      font-size:9px;
      padding:4px 8px;
      border-radius:999px;
      background:#022c22;
      color:#6ee7b7;
      border:1px solid #10b981;
    }

    .content-section {
      background:radial-gradient(circle at 0 0,#0b151d 0,#02060c 60%);
      border-radius:var(--radius-lg);
      padding:24px 22px;
      box-shadow:var(--shadow);
      border:1px solid var(--border);
      margin-bottom:28px;
    }

    h2 {
      color:var(--accent);
      font-size:18px;
      margin-bottom:18px;
      text-shadow:0 0 6px var(--accent);
    }

    p, li, label, input, select, button, small {
      color:var(--text-soft);
      font-size:12px;
      line-height:1.8;
    }

    ul {
      list-style:none;
      padding:0;
      margin:0;
    }
    ul li::before {
      content:"‚Ä¢ ";
      color:var(--accent);
      font-weight:bold;
      margin-right:8px;
    }

    .game-grid {
      display:grid;
      gap:18px;
      grid-template-columns: 1fr;
    }
    @media(min-width: 980px){
      .game-grid {
        grid-template-columns: 1.1fr 0.9fr;
      }
    }

    .panel {
      background:#020a06;
      border:2px solid #12442d;
      border-radius:var(--radius);
      padding:18px;
      box-shadow:inset 0 0 12px #06130f, 0 0 24px #39ff141c;
    }

    .row {
      display:flex;
      gap:12px;
      flex-wrap:wrap;
      align-items:center;
      margin-bottom:12px;
    }
    .row > * { flex:1; min-width: 120px; }

    .control {
      display:flex;
      flex-direction:column;
      gap:6px;
      background:#061a12;
      border:1px solid #0f3b27;
      border-radius:12px;
      padding:10px 12px;
    }
    .control label { font-size:10px; text-transform:uppercase; letter-spacing:.6px; color:#7fe9b7; }
    .control input[type="number"],
    .control input[type="text"],
    .control select,
    .control input[type="range"] {
      background:#03140e;
      border:1px solid #0f3b27;
      border-radius:8px;
      padding:10px 12px;
      color:#b8ffda;
      outline:none;
      box-shadow:inset 0 0 8px #0000007a;
    }
    .control input[type="range"] { padding: 6px 0; }

    .stat {
      background:#061a12;
      border:1px solid #0f3b27;
      border-radius:12px;
      padding:10px 12px;
      display:flex;
      flex-direction:column;
      gap:4px;
    }
    .stat .label { color:#7fe9b7; font-size:10px; opacity:.9; }
    .stat .value { color:var(--accent); font-size:14px; text-shadow:0 0 6px #39ff1466; }

    .btn {
      display:inline-flex; align-items:center; justify-content:center;
      gap:8px;
      background:#0f2b1c;
      color:#a9ffcf;
      border:2px solid #1e5a3c;
      padding:12px 16px;
      border-radius:12px;
      text-decoration:none;
      font-size:12px;
      cursor:pointer;
      box-shadow:0 0 8px #39ff1433, 2px 2px 0 #001c0d;
      transition:transform .12s, box-shadow .12s, background .12s, opacity .12s;
      user-select:none;
      white-space:nowrap;
    }
    .btn:hover { transform:translateY(-2px); box-shadow:0 0 14px var(--accent), 4px 4px 0 #001c0d; }
    .btn:disabled { opacity:.5; cursor:not-allowed; transform:none; box-shadow:none; }
    .btn.primary { background:#103c2a; border-color:#1e6a48; color:#caffdf; }
    .btn.danger { background:#2a1210; border-color:#6a1e1e; color:#ffd0d0; }

    .roller {
      background:#061a12;
      border:1px solid #0f3b27;
      border-radius:12px;
      padding:16px;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:16px;
      align-items:center;
      justify-items:center;
      min-height:160px;
    }

    .die {
      width:120px; height:120px;
      border-radius:16px;
      background:radial-gradient(100% 100% at 50% 50%, #0e2c1f 0%, #071b13 100%);
      border:2px solid #1e5a3c;
      box-shadow:inset 0 0 16px #0c2d20, 0 6px 20px #000000aa;
      display:flex; align-items:center; justify-content:center;
      color:#39ff14; font-size:48px;
      position:relative;
      perspective: 600px;
      transform-style: preserve-3d;
    }

    .die.spin {
      animation: spin 0.6s ease-in-out;
    }
    @keyframes spin {
      0% { transform:rotateX(0) rotateY(0) }
      30% { transform:rotateX(160deg) rotateY(120deg) }
      70% { transform:rotateX(240deg) rotateY(260deg) }
      100% { transform:rotateX(360deg) rotateY(360deg) }
    }

    .sum-banner {
      margin-top:12px;
      text-align:center;
      color:#7fe9b7;
    }
    .sum-banner .sum {
      color:#39ff14; font-size:16px; text-shadow:0 0 8px #39ff1477;
    }

    .chips {
      display:flex; gap:8px; flex-wrap:wrap;
    }
    .chip {
      background:#0b2519;
      border:1px dashed #2a7a55;
      color:#a9ffcf;
      padding:8px 10px;
      border-radius:999px;
      cursor:pointer;
      transition:transform .1s, box-shadow .1s;
      box-shadow:0 0 8px #39ff1420;
      user-select:none;
    }
    .chip:hover { transform:translateY(-1px); box-shadow:0 0 12px #39ff1455; }

    .pfair {
      background:#061a12;
      border:1px dashed #275a41;
      border-radius:12px;
      padding:12px;
      display:grid; gap:8px;
    }
    .pfair code {
      background:#03140e; border:1px solid #0f3b27; border-radius:8px; padding:6px 8px; display:block; overflow:auto;
      color:#b8ffda;
    }
    .muted { color:var(--muted); opacity:.9; }

    table.history {
      width:100%; border-collapse:collapse; margin-top:8px;
      font-size:11px;
    }
    table.history th, table.history td {
      border-bottom:1px solid #103624;
      padding:6px 6px; text-align:left; color:#b8ffda;
      white-space:nowrap;
    }
    table.history th { color:#7fe9b7; font-weight:normal; }
    table.history tr.win td { color:#caffdf; }
    table.history tr.lose td { color:#ffd0d0; }
    .scroll {
      max-height:260px; overflow:auto; border:1px solid #0f3b27; border-radius:12px; padding:8px;
      background:#061a12;
    }

    .tag {
      background:#0b2519; border:1px solid #1e5a3c; border-radius:8px; padding:2px 6px; color:#a9ffcf; font-size:10px;
    }
  </style>
</head>
<body>
  <div class="container">
    <a href="../index.html#games" class="back-link">‚Üê Back to Casino</a>
    <h1>üé≤ PBJ DICE</h1>

    <div class="hero-section">
      <div class="hero-image">
        Welcome to the PBJ Dice demo! Play with a fake PBJ balance only ‚Äî no blockchain and no real tokens.
        Includes a simplified provably-fair style generator so you can inspect how rolls are produced.
      </div>
      <h2>Bet & Win on Every Roll</h2>
      <p>
        Choose your bet, pick a target number and predict whether the final sum of two dice
        will be higher, lower or exactly equal to your target. ‚ÄúExact‚Äù pays higher, but hits
        less often. Payouts are probability-based with a 1% demo house edge.
      </p>
    </div>

    <div class="game-grid">
      <!-- LEFT: GAME -->
      <div class="panel">
        <h2>üéÆ Game Panel</h2>

        <div class="row">
          <div class="control" style="flex:1.2">
            <label for="bet">Bet (PBJ)</label>
            <div class="row" style="gap:8px">
              <input type="number" id="bet" min="1" step="1" value="10" />
              <div class="chips">
                <span class="chip" data-add="10">+10</span>
                <span class="chip" data-add="50">+50</span>
                <span class="chip" data-mul="2">x2</span>
                <span class="chip" data-half="1">1/2</span>
                <span class="chip" data-max="1">MAX</span>
              </div>
            </div>
            <small class="muted">Demo balance: <span id="balance">1000</span> PBJ ‚Ä¢ Rolls remaining: <span id="playsLeft">50</span></small>
          </div>

          <div class="control">
            <label for="mode">Mode</label>
            <select id="mode">
              <option value="over">Over</option>
              <option value="under">Under</option>
              <option value="exact">Exact</option>
            </select>
          </div>

          <div class="control">
            <label for="target">Target: <span id="targetVal">7</span></label>
            <input type="range" id="target" min="2" max="12" value="7" />
          </div>
        </div>

        <div class="row">
          <div class="stat">
            <span class="label">Probability</span>
            <span class="value" id="prob">‚Äî</span>
          </div>
          <div class="stat">
            <span class="label">Multiplier (demo)</span>
            <span class="value" id="mult">‚Äî</span>
          </div>
          <div class="stat">
            <span class="label">Potential profit</span>
            <span class="value" id="potential">‚Äî</span>
          </div>
          <div class="stat">
            <span class="label">Record</span>
            <span class="value"><span id="wins">0</span> W / <span id="losses">0</span> L</span>
          </div>
        </div>

        <div class="roller" id="roller">
          <div class="die" id="die1"><span id="d1">‚Äî</span></div>
          <div class="die" id="die2"><span id="d2">‚Äî</span></div>
        </div>
        <div class="sum-banner">
          Result: <span class="sum" id="sum">‚Äî</span>
        </div>

        <div class="row" style="margin-top:14px">
          <button class="btn primary" id="rollBtn">ROLL</button>
          <button class="btn" id="autoBtn" data-running="0">Auto-roll: OFF</button>
          <button class="btn danger" id="resetBtn">Reset Demo</button>
        </div>
        <small class="muted">
          Demo mechanic: bet is removed at each roll and winners are paid bet √ó multiplier.
        </small>
      </div>

      <!-- RIGHT: HISTORY + PROVABLY FAIR -->
      <div class="panel">
        <h2>üìú History</h2>
        <div class="scroll">
          <table class="history" id="history">
            <thead>
              <tr>
                <th>Time</th>
                <th>Bet</th>
                <th>Mode</th>
                <th>Target</th>
                <th>D1</th>
                <th>D2</th>
                <th>Sum</th>
                <th>Mult</th>
                <th>Result</th>
                <th>Balance</th>
              </tr>
            </thead>
            <tbody id="historyBody"></tbody>
          </table>
        </div>

        <h2 style="margin-top:18px">üß™ Provably Fair (Demo)</h2>
        <div class="pfair">
          <div>
            <span class="tag">Server seed (static demo)</span>
            <code id="serverSeed"></code>
          </div>
          <div>
            <span class="tag">Client seed</span>
            <code id="clientSeed"></code>
          </div>
          <div class="row" style="margin:0">
            <button class="btn" id="regenClient">Regenerate client seed</button>
            <div class="stat" style="min-width:160px">
              <span class="label">Nonce</span>
              <span class="value" id="nonce">0</span>
            </div>
          </div>
          <small class="muted">
            Each roll uses SHA-256 over <code>serverSeed-clientSeed-nonce-index</code>.
            To verify, recompute the hash and map it into 1‚Äì6 to rebuild both dice.
          </small>
        </div>
      </div>
    </div>

    <div class="content-section" style="margin-top:30px">
      <h2>üìã How to Play</h2>
      <ul>
        <li>Choose your bet in PBJ (demo balance only).</li>
        <li>Select a target number from 2 to 12.</li>
        <li>Pick ‚ÄúOver‚Äù, ‚ÄúUnder‚Äù or ‚ÄúExact‚Äù.</li>
        <li>Press ROLL or enable Auto-roll.</li>
        <li>If your prediction is correct, you receive bet √ó multiplier.</li>
      </ul>
    </div>

    <div class="content-section">
      <h2>üéØ Game Modes</h2>
      <p>
        Classic dice-style betting: predict if the sum of two dice will be above or below a target.
        ‚ÄúExact‚Äù pays the highest multipliers but is the hardest to hit. Multipliers are derived
        from the true probability distribution of 2‚Äì12 and adjusted with a 1% demo house edge.
      </p>
    </div>

    <div class="content-section">
      <h2>üíé Demo Features</h2>
      <ul>
        <li>Animated dice with spin effect.</li>
        <li>Provably-fair style RNG (server/client seed + nonce).</li>
        <li>Auto-roll for continuous testing.</li>
        <li>History and basic stats for the current session.</li>
      </ul>
    </div>
  </div>

  <script>
    ;(() => {
      // Sum distribution of two fair dice (2..12)
      const SUM_COUNTS = {2:1,3:2,4:3,5:4,6:5,7:6,8:5,9:4,10:3,11:2,12:1};
      const TOTAL_OUTCOMES = 36;
      const HOUSE_EDGE = 0.01; // 1% demo edge

      const state = {
        balance: 1000,
        playsLeft: 50,
        wins: 0,
        losses: 0,
        serverSeed: 'PBJ-DEMO-STATIC-SEED-2025-ALFA',
        clientSeed: '',
        nonce: 0,
        auto: false,
        autoTimer: null,
        rolling: false,
      };

      const el = {
        bet: document.getElementById('bet'),
        balance: document.getElementById('balance'),
        playsLeft: document.getElementById('playsLeft'),
        mode: document.getElementById('mode'),
        target: document.getElementById('target'),
        targetVal: document.getElementById('targetVal'),
        prob: document.getElementById('prob'),
        mult: document.getElementById('mult'),
        potential: document.getElementById('potential'),
        wins: document.getElementById('wins'),
        losses: document.getElementById('losses'),
        die1: document.getElementById('die1'),
        die2: document.getElementById('die2'),
        d1: document.getElementById('d1'),
        d2: document.getElementById('d2'),
        sum: document.getElementById('sum'),
        rollBtn: document.getElementById('rollBtn'),
        autoBtn: document.getElementById('autoBtn'),
        resetBtn: document.getElementById('resetBtn'),
        historyBody: document.getElementById('historyBody'),
        serverSeed: document.getElementById('serverSeed'),
        clientSeed: document.getElementById('clientSeed'),
        nonce: document.getElementById('nonce'),
        regenClient: document.getElementById('regenClient'),
      };

      const fmt = (n, d=2) =>
        Number(n).toLocaleString('en-US', { minimumFractionDigits:d, maximumFractionDigits:d });
      const nowTime = () =>
        new Date().toLocaleTimeString([], { hour12:false });

      function clampBet() {
        const max = state.balance;
        let v = parseInt(el.bet.value || '0', 10);
        if (isNaN(v)) v = 1;
        if (v < 1) v = 1;
        if (v > max) v = Math.max(1, Math.floor(max));
        el.bet.value = String(v);
        return v;
      }

      function probOf(mode, target) {
        target = Number(target);
        let favorable = 0;
        if (mode === 'over') {
          for (let s = target+1; s <= 12; s++) favorable += SUM_COUNTS[s] || 0;
        } else if (mode === 'under') {
          for (let s = 2; s < target; s++) favorable += SUM_COUNTS[s] || 0;
        } else if (mode === 'exact') {
          favorable = SUM_COUNTS[target] || 0;
        }
        const p = favorable / TOTAL_OUTCOMES;
        return Math.max(0, Math.min(1, p));
      }

      function multiplierOf(p) {
        if (p <= 0) return Infinity;
        const m = (1 - HOUSE_EDGE) / p;
        return Math.max(1.01, Math.floor(m * 100) / 100);
      }

      function updateQuotes() {
        const bet = clampBet();
        const target = Number(el.target.value);
        const mode = el.mode.value;
        el.targetVal.textContent = String(target);

        const p = probOf(mode, target);
        const m = multiplierOf(p);
        const potentialGain = bet * (m - 1);

        el.prob.textContent = (p*100).toFixed(2) + '%';
        el.mult.textContent = isFinite(m) ? m.toFixed(2) + 'x' : '‚Äî';
        el.potential.textContent = isFinite(m) ? fmt(potentialGain) + ' PBJ' : '‚Äî';

        const impossible = p <= 0 || !isFinite(m);
        el.rollBtn.disabled =
          state.rolling ||
          state.playsLeft <= 0 ||
          bet > state.balance ||
          impossible;
      }

      async function sha256Hex(str) {
        const enc = new TextEncoder().encode(str);
        const buf = await crypto.subtle.digest('SHA-256', enc);
        return Array.from(new Uint8Array(buf))
          .map(b => b.toString(16).padStart(2,'0'))
          .join('');
      }

      async function fairDie(index) {
        const input = `${state.serverSeed}-${state.clientSeed}-${state.nonce}-${index}`;
        const hex = await sha256Hex(input);
        const start = (index % 7) * 8;
        const block = hex.slice(start, start + 8);
        const num = parseInt(block, 16);
        const val = (num % 6) + 1;
        return val;
      }

      async function fairRoll() {
        const d1 = await fairDie(0);
        const d2 = await fairDie(1);
        return { d1, d2, sum: d1 + d2 };
      }

      function loadState() {
        try {
          const saved = JSON.parse(localStorage.getItem('pbj_dice_demo') || '{}');
          if (saved && typeof saved === 'object') {
            if (typeof saved.balance === 'number') state.balance = saved.balance;
            if (typeof saved.playsLeft === 'number') state.playsLeft = saved.playsLeft;
            if (typeof saved.wins === 'number') state.wins = saved.wins;
            if (typeof saved.losses === 'number') state.losses = saved.losses;
            if (typeof saved.clientSeed === 'string') state.clientSeed = saved.clientSeed;
            if (typeof saved.nonce === 'number') state.nonce = saved.nonce;
          }
        } catch {}
        if (!state.clientSeed) {
          state.clientSeed = genClientSeed();
        }
      }

      function saveState() {
        const data = {
          balance: state.balance,
          playsLeft: state.playsLeft,
          wins: state.wins,
          losses: state.losses,
          clientSeed: state.clientSeed,
          nonce: state.nonce,
        };
        localStorage.setItem('pbj_dice_demo', JSON.stringify(data));
      }

      function genClientSeed() {
        const r = crypto.getRandomValues(new Uint32Array(3));
        return `client-${r[0].toString(16)}${r[1].toString(16)}${r[2].toString(16)}`;
      }

      function updateTopline() {
        el.balance.textContent = fmt(state.balance, 0);
        el.playsLeft.textContent = state.playsLeft;
        el.wins.textContent = state.wins;
        el.losses.textContent = state.losses;
        el.serverSeed.textContent = state.serverSeed;
        el.clientSeed.textContent = state.clientSeed;
        el.nonce.textContent = state.nonce;
        updateQuotes();
      }

      function setDiceDisplay(d1, d2, animate=true) {
        el.d1.textContent = d1;
        el.d2.textContent = d2;
        el.sum.textContent = (isNaN(d1) || isNaN(d2)) ? '‚Äî' : d1 + d2;
        if (animate && !isNaN(d1) && !isNaN(d2)) {
          el.die1.classList.remove('spin');
          el.die2.classList.remove('spin');
          void el.die1.offsetWidth;
          void el.die2.offsetWidth;
          el.die1.classList.add('spin');
          el.die2.classList.add('spin');
        }
      }

      function addHistoryEntry(entry) {
        const tr = document.createElement('tr');
        tr.className = entry.win ? 'win' : 'lose';
        tr.innerHTML = `
          <td>${entry.time}</td>
          <td>${fmt(entry.bet, 0)}</td>
          <td>${entry.mode}</td>
          <td>${entry.target}</td>
          <td>${entry.d1}</td>
          <td>${entry.d2}</td>
          <td>${entry.sum}</td>
          <td>${entry.mult.toFixed(2)}x</td>
          <td>${entry.win ? 'WIN' : 'LOSE'}</td>
          <td>${fmt(entry.balance, 0)}</td>
        `;
        el.historyBody.prepend(tr);
      }

      function evaluateWin(sum, mode, target) {
        if (mode === 'over') return sum > target;
        if (mode === 'under') return sum < target;
        if (mode === 'exact') return sum === target;
        return false;
      }

      async function rollOnce() {
        if (state.rolling) return;
        const bet = clampBet();
        if (bet > state.balance || bet < 1) { updateQuotes(); return; }
        if (state.playsLeft <= 0) { updateQuotes(); return; }

        state.rolling = true;
        el.rollBtn.disabled = true;

        setDiceDisplay(NaN, NaN, false);
        el.d1.textContent = '‚Ä¢';
        el.d2.textContent = '‚Ä¢';
        el.sum.textContent = '‚Ä¶';

        state.nonce += 1;
        saveState();
        updateTopline();

        await new Promise(r => setTimeout(r, 220));

        const { d1, d2, sum } = await fairRoll();
        setDiceDisplay(d1, d2, true);

        const mode = el.mode.value;
        const target = Number(el.target.value);
        const p = probOf(mode, target);
        const m = multiplierOf(p);
        const win = evaluateWin(sum, mode, target);

        state.balance = Math.max(0, state.balance - bet);
        let payout = 0;
        if (win) {
          payout = bet * m;
          state.balance = Math.max(0, state.balance + payout);
          state.wins += 1;
        } else {
          state.losses += 1;
        }
        state.playsLeft = Math.max(0, state.playsLeft - 1);

        addHistoryEntry({
          time: nowTime(),
          bet, mode, target,
          d1, d2, sum,
          mult: m,
          win,
          balance: state.balance
        });

        saveState();
        updateTopline();

        state.rolling = false;
        const impossible = p <= 0 || !isFinite(m);
        el.rollBtn.disabled =
          state.playsLeft <= 0 ||
          bet > state.balance ||
          impossible;
      }

      function toggleAuto() {
        state.auto = !state.auto;
        el.autoBtn.textContent = `Auto-roll: ${state.auto ? 'ON' : 'OFF'}`;
        el.autoBtn.dataset.running = state.auto ? '1' : '0';
        if (state.auto) {
          const loop = async () => {
            if (!state.auto) return;
            const bet = clampBet();
            if (state.playsLeft <= 0 || state.balance < bet) {
              state.auto = false;
              el.autoBtn.textContent = 'Auto-roll: OFF';
              return;
            }
            await rollOnce();
            if (state.auto) {
              state.autoTimer = setTimeout(loop, 550);
            }
          };
          loop();
        } else {
          clearTimeout(state.autoTimer);
        }
      }

      function resetDemo() {
        if (!confirm('Reset Dice demo (balance, stats and nonce)?')) return;
        state.balance = 1000;
        state.playsLeft = 50;
        state.wins = 0;
        state.losses = 0;
        state.nonce = 0;
        el.historyBody.innerHTML = '';
        saveState();
        updateTopline();
        setDiceDisplay(NaN, NaN, false);
        el.d1.textContent = '‚Äî';
        el.d2.textContent = '‚Äî';
        el.sum.textContent = '‚Äî';
      }

      // Event bindings
      el.bet.addEventListener('input', updateQuotes);
      el.mode.addEventListener('change', updateQuotes);
      el.target.addEventListener('input', updateQuotes);
      el.rollBtn.addEventListener('click', rollOnce);
      el.autoBtn.addEventListener('click', toggleAuto);
      el.resetBtn.addEventListener('click', resetDemo);

      document.querySelectorAll('.chip').forEach(ch => {
        ch.addEventListener('click', () => {
          let v = parseInt(el.bet.value || '0', 10);
          if (ch.dataset.add) v += parseInt(ch.dataset.add, 10);
          if (ch.dataset.mul) v = Math.ceil(v * parseFloat(ch.dataset.mul));
          if (ch.dataset.half) v = Math.max(1, Math.floor(v/2));
          if (ch.dataset.max) v = Math.max(1, Math.floor(state.balance));
          el.bet.value = String(v);
          updateQuotes();
        });
      });

      el.regenClient.addEventListener('click', () => {
        state.clientSeed = genClientSeed();
        state.nonce = 0;
        saveState();
        updateTopline();
      });

      // Init
      loadState();
      updateTopline();
      setDiceDisplay(NaN, NaN, false);
      el.d1.textContent = '‚Äî';
      el.d2.textContent = '‚Äî';
      el.sum.textContent = '‚Äî';
    })();
  </script>
</body>
</html>
