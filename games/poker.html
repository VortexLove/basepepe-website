<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Poker - Pepe Blackjack Casino</title>
  <meta name="description" content="Play demo Video Poker (Jacks or Better) at PBJ Casino. Practice with fake PBJ balance and provably-fair style shuffling." />
  
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com" crossorigin />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet" />
  
  <style>
    :root {
      color-scheme: dark;
      scroll-behavior:smooth;
      --pbj-neon:#39ff14;
      --pbj-neon-soft:#39ff1490;
      --pbj-border:#123b27;
    }

    html, body { margin:0; padding:0; background:radial-gradient(circle at 10% 0%,#071b12 0,#000 50%,#000 100%); }
    html, body, * { font-family:'Press Start 2P', cursive !important; }
    body { -webkit-font-smoothing:antialiased; text-rendering:optimizeLegibility; color:#e5e7eb; }
    img { max-width:100%; height:auto; display:block; }

    body::before {
      content:"";
      position:fixed;
      inset:0;
      pointer-events:none;
      background:
        radial-gradient(circle at 0% 0%, #39ff140f 0, transparent 55%),
        radial-gradient(circle at 100% 100%, #2563eb12 0, transparent 60%);
      z-index:-2;
    }
    body::after {
      content:"";
      position:fixed;
      inset:0;
      pointer-events:none;
      background-image:
        linear-gradient(#0b13201a 1px, transparent 1px),
        linear-gradient(90deg, #0b13201a 1px, transparent 1px);
      background-size:32px 32px;
      mix-blend-mode:soft-light;
      opacity:.65;
      z-index:-2;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 40px 20px 120px;
    }

    .back-link {
      display:inline-flex;
      align-items:center;
      gap:6px;
      background:#0f2b1c;
      color:#a9ffcf;
      border:2px solid #1e5a3c;
      padding:10px 16px;
      border-radius:999px;
      text-decoration:none;
      font-size:11px;
      margin-bottom:30px;
      box-shadow:0 0 8px #39ff1433, 2px 2px 0 #001c0d;
      transition:transform .15s, box-shadow .15s, border-color .15s;
    }
    .back-link:hover {
      transform:translateY(-3px);
      box-shadow:0 0 14px var(--pbj-neon), 4px 4px 0 #001c0d;
      border-color:#22c55e;
    }

    h1 {
      color:var(--pbj-neon);
      text-shadow:0 0 14px var(--pbj-neon);
      font-size:26px;
      margin-bottom:26px;
      text-align:center;
    }

    .hero-section {
      background:radial-gradient(circle at 0 0,#0b151d 0,#02060c 60%);
      border-radius:22px;
      padding:26px 24px 30px;
      box-shadow:
        0 0 0 1px #020712,
        0 0 0 2px #06141b,
        0 14px 30px rgba(0,0,0,.8),
        0 0 42px #39ff1420;
      border:1px solid var(--pbj-border);
      margin-bottom:40px;
      position:relative;
      overflow:hidden;
    }
    .hero-section::before {
      content:"";
      position:absolute;
      inset:-3px;
      border-radius:24px;
      z-index:-1;
      background:conic-gradient(from 0deg,#39ff14,#00ffa5,#39ff14);
      filter:blur(18px);
      opacity:.18;
      animation:spinGlow 16s linear infinite;
    }
    @keyframes spinGlow {
      0%{transform:rotate(0);}
      100%{transform:rotate(360deg);}
    }

    .hero-image {
      width:100%;
      border-radius:16px;
      border:2px solid #1e5a3c;
      box-shadow:
        inset 0 0 16px #0c2d20,
        0 10px 30px #000000aa,
        0 0 24px #39ff1422;
      margin-bottom:20px;
      background:radial-gradient(circle at 0 0,#062818 0,#020806 60%);
      min-height:160px;
      display:flex;
      align-items:center;
      justify-content:center;
      color:#bbf7d0;
      font-size:12px;
      padding:16px;
      text-align:center;
      position:relative;
      overflow:hidden;
    }
    .hero-image::after {
      content:"DEMO ONLY ‚Ä¢ NO REAL TOKENS";
      position:absolute;
      left:16px;
      bottom:12px;
      font-size:9px;
      padding:4px 8px;
      border-radius:999px;
      background:#022c22;
      color:#6ee7b7;
      border:1px solid #10b981;
    }

    .content-section {
      background:radial-gradient(circle at 0 0,#0b151d 0,#02060c 60%);
      border-radius:20px;
      padding:24px 22px;
      box-shadow:
        0 0 0 1px #020712,
        0 0 0 2px #06141b,
        0 14px 30px rgba(0,0,0,.8),
        0 0 42px #39ff1420;
      border:1px solid var(--pbj-border);
      margin-bottom:26px;
    }

    h2 {
      color:var(--pbj-neon);
      font-size:18px;
      margin-bottom:18px;
      text-shadow:0 0 6px var(--pbj-neon);
    }

    p, li, label, input, select, button, small {
      color:#b8ffda;
      font-size:12px;
      line-height:1.8;
    }

    ul {
      list-style:none;
      padding:0;
      margin:0;
    }

    ul li::before {
      content:"‚Ä¢ ";
      color:var(--pbj-neon);
      font-weight:bold;
      margin-right:8px;
    }

    .game-grid {
      display:grid;
      gap:18px;
      grid-template-columns: 1fr;
    }
    @media(min-width: 980px){
      .game-grid {
        grid-template-columns: 1.1fr 0.9fr;
      }
    }

    .panel {
      background:#020a06;
      border:2px solid #12442d;
      border-radius:18px;
      padding:18px;
      box-shadow:inset 0 0 12px #06130f, 0 0 24px #39ff141c;
    }

    .row {
      display:flex;
      gap:12px;
      flex-wrap:wrap;
      align-items:center;
      margin-bottom:12px;
    }
    .row > * { flex:1; min-width: 120px; }

    .control {
      display:flex;
      flex-direction:column;
      gap:6px;
      background:#061a12;
      border:1px solid #0f3b27;
      border-radius:12px;
      padding:10px 12px;
    }
    .control input[type="number"] {
      background:#03140e;
      border:1px solid #0f3b27;
      border-radius:8px;
      padding:10px 12px;
      color:#b8ffda;
      outline:none;
      box-shadow:inset 0 0 8px #0000007a;
    }

    .chips {
      display:flex;
      flex-wrap:wrap;
      gap:6px;
      margin-top:8px;
    }
    .chip {
      background:#072818;
      color:var(--pbj-neon);
      border:2px solid var(--pbj-neon);
      padding:6px 10px;
      border-radius:999px;
      font-size:10px;
      box-shadow:0 0 8px #39ff1433;
      cursor:pointer;
      transition:.15s;
    }
    .chip:hover {
      background:var(--pbj-neon);
      color:#01210f;
      box-shadow:0 0 12px var(--pbj-neon-soft);
    }

    .stat {
      background:#061a12;
      border:1px solid #0f3b27;
      border-radius:12px;
      padding:10px 12px;
      display:flex;
      flex-direction:column;
      gap:4px;
    }
    .stat .label { color:#7fe9b7; font-size:10px; opacity:.9; }
    .stat .value { color:var(--pbj-neon); font-size:14px; text-shadow:0 0 6px #39ff1466; }

    .btn {
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:8px;
      background:#0f2b1c;
      color:#a9ffcf;
      border:2px solid #1e5a3c;
      padding:12px 16px;
      border-radius:12px;
      text-decoration:none;
      font-size:12px;
      cursor:pointer;
      box-shadow:0 0 8px #39ff1433, 2px 2px 0 #001c0d;
      transition:transform .12s, box-shadow .12s, background .12s, opacity .12s;
      user-select:none;
      white-space:nowrap;
    }
    .btn:hover { transform:translateY(-2px); box-shadow:0 0 14px var(--pbj-neon), 4px 4px 0 #001c0d; }
    .btn:disabled { opacity:.5; cursor:not-allowed; transform:none; box-shadow:none; }
    .btn.primary { background:#103c2a; border-color:#1e6a48; color:#caffdf; }
    .btn.danger { background:#2a1210; border-color:#6a1e1e; color:#ffd0d0; }

    /* Table / cards */
    .table {
      background: radial-gradient(120% 120% at 50% 0%, #0c1f17 0%, #071a12 45%, #06160f 100%);
      border:2px solid #1e5a3c;
      border-radius:14px;
      box-shadow:
        inset 0 0 16px #0c2d20,
        0 10px 30px #000000aa,
        0 0 24px #39ff1422;
      padding:14px;
    }
    .cards {
      display:flex;
      gap:12px;
      justify-content:center;
      align-items:center;
      flex-wrap:wrap;
      min-height:180px;
      padding:12px;
    }
    .card {
      width:110px;
      height:160px;
      border-radius:12px;
      background:#0b2519;
      border:2px solid #1e5a3c;
      box-shadow:inset 0 0 12px #0c2d20, 0 6px 18px #00000088;
      position:relative;
      display:flex;
      align-items:center;
      justify-content:center;
      color:#caffdf;
      font-size:28px;
      cursor:pointer;
      user-select:none;
      transition:transform .1s, box-shadow .1s, border-color .1s, background .1s;
    }
    .card:hover {
      transform:translateY(-3px);
      box-shadow:0 0 18px var(--pbj-neon-soft), 4px 4px 0 #001c0d;
      background:#0f3021;
    }
    .card .corner {
      position:absolute;
      top:6px;
      left:8px;
      font-size:16px;
      line-height:1.1;
      text-align:left;
    }
    .card .corner.bottom {
      top:auto;
      left:auto;
      bottom:6px;
      right:8px;
      transform:rotate(180deg);
    }
    .card .suit {
      font-size:34px;
      opacity:.9;
    }
    .card.red { color:#ffd0d0; }
    .card.held {
      border-color:#f97373;
      box-shadow:0 0 18px #ff6b6b66, inset 0 0 12px #360d0d;
      background:#2a1210;
    }
    .hold-badge {
      position:absolute;
      bottom:8px;
      left:50%;
      transform:translateX(-50%);
      background:#2a1210;
      border:1px solid #f97373;
      border-radius:8px;
      padding:2px 6px;
      color:#ffd0d0;
      font-size:10px;
      display:none;
    }
    .card.held .hold-badge { display:block; }

    .paytable {
      display:grid;
      grid-template-columns: 1fr auto;
      gap:6px 12px;
      background:#061a12;
      border:1px solid #0f3b27;
      border-radius:12px;
      padding:10px 12px;
      margin-top:10px;
      font-size:11px;
    }
    .paytable .h { color:#7fe9b7; }
    .paytable .v { color:#caffdf; text-align:right; cursor:help; }

    .result {
      text-align:center;
      color:#7fe9b7;
      margin-top:10px;
      min-height:20px;
    }

    .scroll {
      max-height:320px;
      overflow:auto;
      border:1px solid #0f3b27;
      border-radius:12px;
      padding:8px;
      background:#061a12;
    }

    table.history {
      width:100%;
      border-collapse:collapse;
      margin-top:8px;
      font-size:11px;
    }
    table.history th, table.history td {
      border-bottom:1px solid #103624;
      padding:6px 4px;
      text-align:left;
      color:#b8ffda;
      white-space:nowrap;
    }
    table.history th { color:#7fe9b7; font-weight:normal; }
    table.history tr.win td { color:#caffdf; }
    table.history tr.lose td { color:#ffd0d0; }

    .pfair {
      background:#061a12;
      border:1px dashed #275a41;
      border-radius:12px;
      padding:12px;
      display:grid;
      gap:8px;
    }
    .pfair code {
      background:#03140e;
      border:1px solid #0f3b27;
      border-radius:8px;
      padding:6px 8px;
      display:block;
      overflow:auto;
      color:#b8ffda;
    }
    .tag {
      background:#0b2519;
      border:1px solid #1e5a3c;
      border-radius:8px;
      padding:2px 6px;
      color:#a9ffcf;
      font-size:10px;
    }

    .muted { opacity:.8; }

    .coming-soon { display:none; }
  </style>
</head>
<body>
  <div class="container">
    <a href="../index.html#games" class="back-link">‚Üê Back to Casino</a>
    
    <h1>üÉè PBJ VIDEO POKER</h1>

    <div class="hero-section">
      <div class="hero-image">
        Demo Video Poker (Jacks or Better). Play with a fake PBJ balance only ‚Äî no blockchain, no real tokens.
        Includes a simplified provably-fair style shuffle so you can inspect how each hand was generated.
      </div>
      
      <h2>The Skill & Strategy Card Game</h2>
      <p>
        Receive 5 cards, choose which ones to hold, and draw replacements for the rest.
        Get paid according to the paytable ‚Äî from Jacks or Better all the way up to a Royal Flush.
        This demo roughly emulates a 9/6 Jacks or Better paytable.
      </p>
    </div>

    <div class="game-grid">
      <!-- LEFT: TABLE -->
      <div class="panel">
        <h2>üéÆ Video Poker Table</h2>

        <div class="row">
          <div class="control" style="flex:1.3">
            <label for="bet">Bet (PBJ)</label>
            <div class="row" style="gap:8px">
              <input type="number" id="bet" min="1" step="1" value="10" />
              <div class="chips">
                <span class="chip" data-add="10">+10</span>
                <span class="chip" data-add="50">+50</span>
                <span class="chip" data-mul="2">x2</span>
                <span class="chip" data-half="1">1/2</span>
                <span class="chip" data-max="1">MAX</span>
              </div>
            </div>
            <small class="muted">
              Demo balance: <span id="balance">1000</span> PBJ ‚Ä¢ Hands remaining: <span id="playsLeft">50</span>
            </small>
          </div>

          <div class="stat">
            <span class="label">State</span>
            <span class="value" id="phaseText">Ready</span>
          </div>

          <div class="stat">
            <span class="label">Record</span>
            <span class="value"><span id="wins">0</span> W / <span id="losses">0</span> L</span>
          </div>
        </div>

        <div class="table">
          <div class="cards" id="cards"></div>
          <div class="result" id="result">‚Äî</div>
          <div class="paytable" id="paytable">
            <div class="h">Royal Flush</div><div class="v" data-hand="royal_flush">250x</div>
            <div class="h">Straight Flush</div><div class="v" data-hand="straight_flush">50x</div>
            <div class="h">Four of a Kind</div><div class="v" data-hand="four_kind">25x</div>
            <div class="h">Full House</div><div class="v" data-hand="full_house">9x</div>
            <div class="h">Flush</div><div class="v" data-hand="flush">6x</div>
            <div class="h">Straight</div><div class="v" data-hand="straight">4x</div>
            <div class="h">Three of a Kind</div><div class="v" data-hand="three_kind">3x</div>
            <div class="h">Two Pair</div><div class="v" data-hand="two_pair">2x</div>
            <div class="h">Jacks or Better</div><div class="v" data-hand="jacks_or_better">1x</div>
          </div>
        </div>

        <div class="row" style="margin-top:14px">
          <button class="btn primary" id="dealDrawBtn">DEAL</button>
          <button class="btn" id="autoHoldBtn">Auto-HOLD</button>
          <button class="btn" id="autoBtn" data-running="0">Auto-play: OFF</button>
          <button class="btn danger" id="resetBtn">Reset Demo</button>
        </div>
        <small class="muted">
          Note: In this demo, the bet is subtracted at DEAL and the payout is bet √ó multiplier after DRAW.
        </small>
      </div>

      <!-- RIGHT: HISTORY + PROVABLY FAIR -->
      <div class="panel">
        <h2>üìú History</h2>
        <div class="scroll">
          <table class="history" id="history">
            <thead>
              <tr>
                <th>Time</th>
                <th>Bet</th>
                <th>Cards</th>
                <th>Result</th>
                <th>Payout</th>
                <th>Balance</th>
              </tr>
            </thead>
            <tbody id="historyBody"></tbody>
          </table>
        </div>

        <h2 style="margin-top:18px">üß™ Provably Fair (Demo)</h2>
        <div class="pfair">
          <div>
            <span class="tag">Server seed (demo fixed)</span>
            <code id="serverSeed"></code>
          </div>
          <div>
            <span class="tag">Client seed</span>
            <code id="clientSeed"></code>
          </div>
          <div class="row" style="margin:0">
            <button class="btn" id="regenClient">Regenerate client seed</button>
            <div class="stat" style="min-width:160px">
              <span class="label">Nonce</span>
              <span class="value" id="nonce">0</span>
            </div>
          </div>
          <small class="muted">
            Each hand uses SHA-256 over "serverSeed-clientSeed-nonce-index" to generate deterministic floats
            and run a Fisher‚ÄìYates shuffle on the deck.
          </small>
        </div>
      </div>
    </div>

    <div class="content-section" style="margin-top:30px">
      <h2>üìã How to Play</h2>
      <ul>
        <li>Choose your bet and press DEAL.</li>
        <li>Tap cards to mark them as HOLD.</li>
        <li>Press DRAW to replace the rest.</li>
        <li>Get paid according to the paytable above.</li>
      </ul>
    </div>

    <div class="content-section">
      <h2>üéØ Poker Hands (Jacks or Better)</h2>
      <p>
        Payouts are awarded for: Jacks or Better, Two Pair, Three of a Kind, Straight, Flush,
        Full House, Four of a Kind, Straight Flush and Royal Flush. Use Auto-HOLD to get a basic
        suggested selection according to typical Jacks or Better heuristics.
      </p>
    </div>

    <div class="content-section">
      <h2>üíé Demo Features</h2>
      <ul>
        <li>Provably-fair style seeds + nonce for deterministic shuffles</li>
        <li>Auto-HOLD suggestion and Auto-play loop</li>
        <li>Session history and simple stats</li>
      </ul>
    </div>
  </div>

  <script>
    ;(() => {
      const PAYTABLE = {
        royal_flush: 250,
        straight_flush: 50,
        four_kind: 25,
        full_house: 9,
        flush: 6,
        straight: 4,
        three_kind: 3,
        two_pair: 2,
        jacks_or_better: 1,
      };

      const SUITS = ['‚ô†','‚ô•','‚ô¶','‚ô£']; // 0..3
      const RANKS = [2,3,4,5,6,7,8,9,10,11,12,13,14]; // 11:J,12:Q,13:K,14:A
      const HOUSE_EDGE_INFO = 'Approximate 9/6 Jacks or Better paytable in demo.';

      const state = {
        balance: 1000,
        playsLeft: 50,
        wins: 0,
        losses: 0,
        serverSeed: 'PBJ-POKER-DEMO-SEED-2025',
        clientSeed: '',
        nonce: 0,

        phase: 'ready', // 'ready' | 'draw'
        auto: false,

        currentBet: 0,
        deck: [],
        nextIndex: 0,
        hand: [], // [{rank,suit,held}]
      };

      const el = {
        bet: document.getElementById('bet'),
        balance: document.getElementById('balance'),
        playsLeft: document.getElementById('playsLeft'),
        wins: document.getElementById('wins'),
        losses: document.getElementById('losses'),

        cards: document.getElementById('cards'),
        result: document.getElementById('result'),
        dealDrawBtn: document.getElementById('dealDrawBtn'),
        autoHoldBtn: document.getElementById('autoHoldBtn'),
        autoBtn: document.getElementById('autoBtn'),
        resetBtn: document.getElementById('resetBtn'),

        historyBody: document.getElementById('historyBody'),
        phaseText: document.getElementById('phaseText'),

        serverSeed: document.getElementById('serverSeed'),
        clientSeed: document.getElementById('clientSeed'),
        nonce: document.getElementById('nonce'),
        regenClient: document.getElementById('regenClient'),
      };

      // Utils
      const fmt = (n, d=2) => Number(n).toLocaleString('en-US', {minimumFractionDigits:d, maximumFractionDigits:d});
      const nowTime = () => new Date().toLocaleTimeString([], {hour12:false});

      function clampBet() {
        const max = state.balance;
        let v = parseInt(el.bet.value || '0', 10);
        if (v < 1) v = 1;
        if (v > max) v = Math.max(1, Math.floor(max));
        el.bet.value = String(v);
        return v;
      }

      // Storage
      function load() {
        try {
          const saved = JSON.parse(localStorage.getItem('pbj_poker_demo') || '{}');
          if (saved && typeof saved === 'object') {
            ['balance','playsLeft','wins','losses','clientSeed','nonce'].forEach(k => {
              if (k in saved) state[k] = saved[k];
            });
          }
        } catch {}
        if (!state.clientSeed) state.clientSeed = genClientSeed();
      }
      function save() {
        const data = {
          balance: state.balance,
          playsLeft: state.playsLeft,
          wins: state.wins,
          losses: state.losses,
          clientSeed: state.clientSeed,
          nonce: state.nonce,
        };
        localStorage.setItem('pbj_poker_demo', JSON.stringify(data));
      }
      function genClientSeed() {
        const r = crypto.getRandomValues(new Uint32Array(3));
        return `client-${r[0].toString(16)}${r[1].toString(16)}${r[2].toString(16)}`;
      }

      // Provably fair RNG
      async function sha256Hex(str) {
        const enc = new TextEncoder().encode(str);
        const buf = await crypto.subtle.digest('SHA-256', enc);
        const byteArray = Array.from(new Uint8Array(buf));
        return byteArray.map(b => b.toString(16).padStart(2, '0')).join('');
      }
      async function fairFloats(count) {
        const floats = [];
        let index = 0;
        while (floats.length < count) {
          const hex = await sha256Hex(`${state.serverSeed}-${state.clientSeed}-${state.nonce}-${index}`);
          for (let off=0; off+8<=hex.length && floats.length < count; off+=8) {
            const block = hex.slice(off, off+8);
            const num = parseInt(block, 16) >>> 0;
            floats.push(num / 0x100000000);
          }
          index++;
        }
        return floats;
      }

      function newOrderedDeck() {
        const deck = [];
        for (let s=0; s<4; s++) {
          for (let r of RANKS) {
            deck.push({ rank: r, suit: s });
          }
        }
        return deck;
      }

      async function shuffleDeck() {
        // Fisher‚ÄìYates using deterministic floats
        let deck = newOrderedDeck();
        const rnd = await fairFloats(52);
        for (let i = deck.length - 1; i > 0; i--) {
          const j = Math.floor(rnd[deck.length - 1 - i] * (i + 1));
          [deck[i], deck[j]] = [deck[j], deck[i]];
        }
        return deck;
      }

      function renderCards(interactive=true) {
        el.cards.innerHTML = '';
        state.hand.forEach((c, idx) => {
          const div = document.createElement('div');
          const isRed = (c.suit === 1 || c.suit === 2);
          div.className = 'card' + (isRed ? ' red' : '') + (c.held ? ' held' : '');
          div.dataset.index = idx;

          const rankStr = rankToString(c.rank);
          const suitStr = SUITS[c.suit];

          div.innerHTML = `
            <div class="corner">${rankStr}<br>${suitStr}</div>
            <div class="corner bottom">${rankStr}<br>${suitStr}</div>
            <div class="suit">${suitStr}</div>
            <div class="hold-badge">HOLD</div>
          `;

          if (interactive && state.phase === 'draw') {
            div.addEventListener('click', () => toggleHold(idx));
          }
          el.cards.appendChild(div);
        });
      }

      function rankToString(r) {
        if (r <= 10) return String(r);
        return {11:'J',12:'Q',13:'K',14:'A'}[r];
      }

      function addHistory(entry) {
        const tr = document.createElement('tr');
        tr.className = entry.win ? 'win' : 'lose';
        tr.innerHTML = `
          <td>${entry.time}</td>
          <td>${fmt(entry.bet, 0)}</td>
          <td>${entry.cards}</td>
          <td>${entry.handName}</td>
          <td>${entry.win ? '+'+fmt(entry.payout,2) : '-'+fmt(entry.bet,2)}</td>
          <td>${fmt(entry.balance, 0)}</td>
        `;
        el.historyBody.prepend(tr);
      }

      function updateTopline() {
        el.balance.textContent = fmt(state.balance, 0);
        el.playsLeft.textContent = state.playsLeft;
        el.wins.textContent = state.wins;
        el.losses.textContent = state.losses;
        el.serverSeed.textContent = state.serverSeed;
        el.clientSeed.textContent = state.clientSeed;
        el.nonce.textContent = state.nonce;
        el.phaseText.textContent = state.phase === 'ready'
          ? 'Ready'
          : 'Select cards to HOLD, then DRAW';

        const bet = clampBet();
        el.dealDrawBtn.disabled =
          (state.phase === 'ready' && (state.playsLeft <= 0 || bet > state.balance)) ||
          (state.phase === 'draw' && state.playsLeft <= 0);
      }

      async function deal() {
        if (state.phase !== 'ready') return;
        const bet = clampBet();
        if (bet > state.balance || bet < 1) { updateTopline(); return; }
        if (state.playsLeft <= 0) { updateTopline(); return; }

        // Consume bet at DEAL
        state.currentBet = bet;
        state.balance = Math.max(0, state.balance - bet);
        state.playsLeft = Math.max(0, state.playsLeft - 1);

        // Advance nonce and shuffle deterministically
        state.nonce += 1;
        state.deck = await shuffleDeck();
        state.nextIndex = 0;

        // Deal 5 cards
        state.hand = [];
        for (let i=0; i<5; i++) {
          const card = state.deck[state.nextIndex++];
          state.hand.push({ ...card, held: false });
        }

        state.phase = 'draw';
        el.result.textContent = 'Select cards to HOLD and press DRAW.';
        el.dealDrawBtn.textContent = 'DRAW';
        renderCards(true);
        updateTopline();
        save();
      }

      function toggleHold(i) {
        if (state.phase !== 'draw') return;
        state.hand[i].held = !state.hand[i].held;
        renderCards(true);
      }

      async function drawAndResolve() {
        if (state.phase !== 'draw') return;

        // Replace non-held cards
        for (let i=0; i<5; i++) {
          if (!state.hand[i].held) {
            const card = state.deck[state.nextIndex++];
            state.hand[i] = { ...card, held: false };
          }
        }

        // Evaluate
        const evalRes = evaluateHand(state.hand.map(c => ({rank:c.rank, suit:c.suit})));
        const mult = handToMultiplier(evalRes.hand);
        const payout = mult * state.currentBet;

        const win = mult > 0;
        if (win) state.wins += 1; else state.losses += 1;
        state.balance = Math.max(0, state.balance + payout);

        // Show
        renderCards(false);
        const handName = handToName(evalRes.hand);
        el.result.textContent = win
          ? `You win ${mult.toFixed(0)}x (${handName}) ‚Ä¢ +${fmt(payout,2)} PBJ`
          : `No win (${handName}) ‚Ä¢ -${fmt(state.currentBet,2)} PBJ`;

        // History
        addHistory({
          time: nowTime(),
          bet: state.currentBet,
          cards: state.hand.map(c => rankToString(c.rank)+SUITS[c.suit]).join(' '),
          handName,
          payout,
          win,
          balance: state.balance
        });

        // Reset to ready
        state.phase = 'ready';
        state.currentBet = 0;
        el.dealDrawBtn.textContent = 'DEAL';
        updateTopline();
        save();
      }

      function handToMultiplier(hand) {
        return ({
          royal_flush: PAYTABLE.royal_flush,
          straight_flush: PAYTABLE.straight_flush,
          four_kind: PAYTABLE.four_kind,
          full_house: PAYTABLE.full_house,
          flush: PAYTABLE.flush,
          straight: PAYTABLE.straight,
          three_kind: PAYTABLE.three_kind,
          two_pair: PAYTABLE.two_pair,
          jacks_or_better: PAYTABLE.jacks_or_better,
          none: 0,
        }[hand] || 0);
      }

      function handToName(hand) {
        return ({
          royal_flush: 'Royal Flush',
          straight_flush: 'Straight Flush',
          four_kind: 'Four of a Kind',
          full_house: 'Full House',
          flush: 'Flush',
          straight: 'Straight',
          three_kind: 'Three of a Kind',
          two_pair: 'Two Pair',
          jacks_or_better: 'Jacks or Better',
          none: 'High Card',
        }[hand]);
      }

      function evaluateHand(cards) {
        // cards: [{rank:2..14, suit:0..3}] len=5
        const ranks = cards.map(c => c.rank).sort((a,b)=>a-b);
        const suits = cards.map(c => c.suit);
        const counts = {};
        for (let r of ranks) counts[r]=(counts[r]||0)+1;
        const groups = Object.values(counts).sort((a,b)=>b-a); // e.g., [3,2]
        const isFlush = suits.every(s => s === suits[0]);

        function isStraight(ranksSorted) {
          let normal = true;
          for (let i=1;i<ranksSorted.length;i++){
            if (ranksSorted[i] !== ranksSorted[i-1]+1) { normal=false; break; }
          }
          const wheel = [2,3,4,5,14];
          const wheelOk = ranksSorted.join(',') === wheel.join(',');
          return normal || wheelOk;
        }
        const straight = isStraight(ranks);

        const isRoyal = isFlush && [10,11,12,13,14].every(v => ranks.includes(v));
        if (isRoyal) return { hand: 'royal_flush' };

        if (straight && isFlush) return { hand:'straight_flush' };
        if (groups[0] === 4) return { hand:'four_kind' };
        if (groups[0] === 3 && groups[1] === 2) return { hand:'full_house' };
        if (isFlush) return { hand:'flush' };
        if (straight) return { hand:'straight' };
        if (groups[0] === 3) return { hand:'three_kind' };
        if (groups[0] === 2 && groups[1] === 2) return { hand:'two_pair' };

        if (groups[0] === 2) {
          const pairRank = parseInt(Object.keys(counts).find(r => counts[r]==2),10);
          if (pairRank >= 11 || pairRank === 14) return { hand:'jacks_or_better' };
        }
        return { hand:'none' };
      }

      function autoHold() {
        if (state.phase !== 'draw') return;

        const evalNow = evaluateHand(state.hand.map(c => ({rank:c.rank, suit:c.suit})));
        if (['royal_flush','straight_flush','four_kind','full_house','flush','straight'].includes(evalNow.hand)) {
          state.hand.forEach(c => c.held = true);
          renderCards(true);
          return;
        }

        const counts = {};
        state.hand.forEach(c => counts[c.rank] = (counts[c.rank]||0)+1);
        let trioRank = Object.keys(counts).find(r => counts[r]===3);
        const pairRanks = Object.keys(counts).filter(r => counts[r]===2).map(x=>parseInt(x,10));

        if (trioRank) {
          state.hand.forEach(c => c.held = (c.rank == trioRank));
          renderCards(true);
          return;
        }

        if (pairRanks.length === 2) {
          state.hand.forEach(c => c.held = pairRanks.includes(c.rank));
          renderCards(true);
          return;
        }

        if (pairRanks.length === 1 && (pairRanks[0] >= 11 || pairRanks[0] === 14)) {
          state.hand.forEach(c => c.held = (c.rank === pairRanks[0]));
          renderCards(true);
          return;
        }

        const suitCounts = {};
        state.hand.forEach(c => suitCounts[c.suit]=(suitCounts[c.suit]||0)+1);
        const suit4 = Object.keys(suitCounts).find(s => suitCounts[s]>=4);
        if (suit4 != null) {
          const s4 = parseInt(suit4,10);
          state.hand.forEach(c => c.held = (c.suit === s4));
          renderCards(true);
          return;
        }

        const highs = new Set([11,12,13,14]);
        let countHigh=0;
        state.hand.forEach(c => { c.held = highs.has(c.rank); if (c.held) countHigh++; });
        if (countHigh>0) { renderCards(true); return; }

        state.hand.forEach(c => c.held = false);
        renderCards(true);
      }

      function toggleAuto() {
        state.auto = !state.auto;
        el.autoBtn.textContent = `Auto-play: ${state.auto ? 'ON' : 'OFF'}`;
        if (state.auto) {
          const loop = async () => {
            if (!state.auto) return;
            if (state.phase === 'ready') {
              if (state.playsLeft <= 0 || clampBet() > state.balance) {
                state.auto=false;
                el.autoBtn.textContent='Auto-play: OFF';
                return;
              }
              await deal();
              setTimeout(() => {
                if (state.auto) {
                  autoHold();
                  drawAndResolve();
                  setTimeout(loop, 600);
                }
              }, 300);
            } else if (state.phase === 'draw') {
              autoHold();
              await drawAndResolve();
              setTimeout(loop, 600);
            }
          };
          loop();
        }
      }

      function resetDemo() {
        state.balance = 1000;
        state.playsLeft = 50;
        state.wins = 0;
        state.losses = 0;
        state.nonce = 0;
        state.phase = 'ready';
        el.historyBody.innerHTML = '';
        el.result.textContent = '‚Äî';
        state.hand = [];
        renderCards(false);
        el.dealDrawBtn.textContent = 'DEAL';
        updateTopline();
        save();
      }

      function attachEvents() {
        el.dealDrawBtn.addEventListener('click', async () => {
          if (state.phase === 'ready') await deal();
          else await drawAndResolve();
        });
        el.autoHoldBtn.addEventListener('click', autoHold);
        el.autoBtn.addEventListener('click', toggleAuto);
        el.resetBtn.addEventListener('click', resetDemo);

        el.bet.addEventListener('input', updateTopline);

        document.querySelectorAll('.chip').forEach(ch => {
          ch.addEventListener('click', () => {
            let v = parseInt(el.bet.value || '0', 10);
            if (ch.dataset.add) v += parseInt(ch.dataset.add, 10);
            if (ch.dataset.mul) v = Math.ceil(v * parseFloat(ch.dataset.mul));
            if (ch.dataset.half) v = Math.max(1, Math.floor(v/2));
            if (ch.dataset.max) v = Math.max(1, Math.floor(state.balance));
            el.bet.value = String(v);
            updateTopline();
          });
        });

        el.regenClient.addEventListener('click', () => {
          state.clientSeed = genClientSeed();
          state.nonce = 0;
          save();
          updateTopline();
        });
      }

      // Init
      function init() {
        load();
        state.hand = [];
        renderCards(false);
        attachEvents();
        updateTopline();

        el.serverSeed.textContent = state.serverSeed;
        el.clientSeed.textContent = state.clientSeed;
        el.nonce.textContent = state.nonce;

        document.querySelectorAll('#paytable .v').forEach(v => {
          v.title = HOUSE_EDGE_INFO;
        });
      }

      init();
    })();
  </script>
</body>
</html>
