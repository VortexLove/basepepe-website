<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Plinko (Improved Demo) - Pepe Blackjack Casino</title>
  <meta name="description" content="Improved PBJ Plinko demo. Smooth animations, multi-drop, provably-fair style verification and advanced metrics." />
  <link rel="preconnect" href="https://fonts.googleapis.com" crossorigin />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet" />

  <style>
    :root {
      color-scheme: dark;
      scroll-behavior: smooth;
      --bg: #020403;
      --panel: #0b1418;
      --panel-alt:#0e1e23;
      --accent: #39ff14;
      --accent-soft:#39ff1455;
      --accent-glow:#39ff1499;
      --border: #1e5a3c;
      --border-alt:#135437;
      --text: #caffdf;
      --text-soft:#b8ffda;
      --danger:#ff4e4e;
      --warn:#ffc34e;
      --success:#39ff14;
      --font:'Press Start 2P', cursive;
      --radius-sm:8px;
      --radius:14px;
      --radius-lg:22px;
      --shadow:0 0 0 3px #11251b inset, 0 14px 30px rgba(0,0,0,.65), 0 0 48px #39ff1428;
    }
    * { box-sizing: border-box; font-family: var(--font)!important; }
    html, body {
      margin:0; padding:0;
      background: radial-gradient(circle at 50% 0%, #03180f 0%, #020a06 50%, #010403 100%);
      min-height:100%;
    }
    body { -webkit-font-smoothing:antialiased; text-rendering:optimizeLegibility; }

    h1, h2, h3 { color: var(--accent); text-shadow:0 0 8px var(--accent); }
    p, small, label, td, th, button, input, select { color: var(--text-soft); }
    a { color: var(--accent); text-decoration:none; }

    .container {
      max-width: 1300px;
      margin:0 auto;
      padding:40px 20px 120px;
      position:relative;
    }

    .back-link {
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:10px 18px;
      background:#0f2b1c;
      border:2px solid var(--border);
      border-radius:var(--radius-sm);
      color:#a9ffcf;
      font-size:11px;
      box-shadow:0 0 10px #39ff1433, 2px 2px 0 #001c0d;
      transition:.18s;
    }
    .back-link:hover { transform:translateY(-3px); box-shadow:0 0 16px var(--accent), 4px 4px 0 #001c0d; }

    h1 {
      font-size:26px;
      text-align:center;
      margin:0 0 34px;
      letter-spacing:1px;
    }

    /* Panels */
    .panel, .hero, .content-section {
      background: linear-gradient(145deg, #091b12 0%, #06120d 60%, #071911 100%);
      border:3px solid #123b27;
      border-radius:var(--radius-lg);
      padding:28px 26px;
      box-shadow:var(--shadow);
      position:relative;
      overflow:hidden;
    }
    .panel::before, .hero::before, .content-section::before {
      content:"";
      position:absolute;
      inset:-3px;
      border-radius:calc(var(--radius-lg) + 2px);
      background:conic-gradient(from 0deg,#00ffa5,#39ff14,#00ffa5);
      filter:blur(24px);
      opacity:.12;
      pointer-events:none;
    }

    .hero {
      margin-bottom:40px;
      display:grid;
      gap:28px;
    }
    @media(min-width:1000px){
      .hero { grid-template-columns: 1.1fr 0.9fr; }
    }

    .hero-block {
      background:#061a12;
      border:2px solid var(--border-alt);
      border-radius:var(--radius);
      padding:18px 20px;
      box-shadow:inset 0 0 18px #0c2d20, 0 0 32px #39ff1420;
      font-size:12px;
      line-height:1.8;
      position:relative;
      overflow:hidden;
    }

    .hero-block code {
      background:#03140e;
      border:1px solid #0f3b27;
      border-radius:6px;
      padding:2px 6px;
      font-size:10px;
    }

    .stats-bar {
      display:flex;
      gap:16px;
      flex-wrap:wrap;
      margin-bottom:18px;
    }
    .stat {
      flex:1;
      min-width:140px;
      background:#081a13;
      border:2px solid #134b31;
      border-radius:var(--radius);
      padding:12px 14px;
      display:flex;
      flex-direction:column;
      gap:4px;
      position:relative;
      overflow:hidden;
    }
    .stat::after {
      content:"";
      position:absolute;
      inset:0;
      background:linear-gradient(135deg,#39ff1400 0%,#39ff1422 100%);
      opacity:.35;
      mix-blend-mode:overlay;
      pointer-events:none;
    }
    .stat .label { font-size:10px; color:#7fe9b7; letter-spacing:.5px; }
    .stat .value { font-size:14px; color:var(--accent); text-shadow:0 0 6px var(--accent-soft); }

    .grid-game {
      display:grid; gap:30px;
    }
    @media(min-width:1100px){
      .grid-game { grid-template-columns: 1.2fr 0.8fr; }
    }

    .control-group {
      display:flex; flex-wrap:wrap; gap:14px; margin-bottom:18px;
    }
    .control {
      flex:1; min-width:200px;
      background:#081a13;
      border:2px solid #134b31;
      border-radius:var(--radius);
      padding:12px 14px;
      display:flex;
      flex-direction:column;
      gap:8px;
      position:relative;
    }
    .control label { font-size:10px; text-transform:uppercase; letter-spacing:.6px; color:#7fe9b7; }
    .control input[type="number"],
    .control input[type="text"],
    .control select,
    .control input[type="range"] {
      background:#03140e;
      border:2px solid #0f3b27;
      border-radius:10px;
      padding:10px 12px;
      color:var(--text);
      outline:none;
      font-size:12px;
      box-shadow:inset 0 0 8px #00000088;
      width:100%;
    }

    .chips { display:flex; gap:8px; flex-wrap:wrap; }
    .chip {
      padding:6px 10px;
      font-size:10px;
      border-radius:999px;
      background:#0b2519;
      border:1px dashed #2a7a55;
      cursor:pointer;
      user-select:none;
      transition:.16s;
      box-shadow:0 0 10px #39ff141a;
      color:#a9ffcf;
    }
    .chip:hover { transform:translateY(-2px); box-shadow:0 0 16px #39ff1466; }

    .btn {
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:8px;
      border:2px solid var(--border);
      background:#0f2b1c;
      color:#caffdf;
      font-size:12px;
      padding:12px 18px;
      border-radius:var(--radius);
      cursor:pointer;
      text-transform:uppercase;
      letter-spacing:.5px;
      box-shadow:0 0 10px #39ff1433, 3px 3px 0 #001c0d;
      transition:.2s;
      position:relative;
      overflow:hidden;
    }
    .btn:hover:not(:disabled) { transform:translateY(-3px); box-shadow:0 0 18px var(--accent), 5px 5px 0 #001c0d; }
    .btn:disabled { opacity:.45; cursor:not-allowed; box-shadow:none; }
    .btn.primary { background:#115034; border-color:#1e6a48; }
    .btn.alt { background:#132e46; border-color:#1b4e6a; }
    .btn.danger { background:#2a1210; border-color:#6a1e1e; color:#ffd0d0; }
    .btn.soft { background:#081a13; border-color:#134b31; }

    .board-wrap {
      background:#061a12;
      border:2px solid #144d35;
      border-radius:var(--radius-lg);
      padding:14px;
      position:relative;
      box-shadow:inset 0 0 18px #0c2d20;
    }
    canvas#board {
      width:100%;
      height:480px;
      display:block;
      background:radial-gradient(120% 160% at 50% 0%, #0c1f17 0%, #071a12 40%, #06160f 100%);
      border:2px solid #1e5a3c;
      border-radius:var(--radius);
      box-shadow:inset 0 0 16px #0c2d20, 0 10px 30px #000000aa, 0 0 34px #39ff1422;
    }

    .payouts {
      display:flex; gap:6px;
      justify-content:space-between;
      align-items:flex-end;
      margin-top:10px;
      flex-wrap:nowrap;
      overflow-x:auto;
      scrollbar-width:none;
    }
    .payout {
      flex:1;
      min-width:60px;
      text-align:center;
      font-size:10px;
      color:#a9ffcf;
      position:relative;
      padding:4px 0;
    }
    .payout span.x {
      display:inline-block;
      padding:4px 6px;
      border-radius:8px;
      background:linear-gradient(135deg,#0b2519,#123b27);
      border:1px solid #1e5a3c;
      box-shadow:0 0 10px #39ff1420;
      transition:.18s;
    }
    .payout.highlight span.x { box-shadow:0 0 14px var(--accent-glow); background:#123b27; }

    .history-wrap {
      background:#081a13;
      border:2px solid #144d35;
      border-radius:var(--radius);
      padding:12px;
      max-height:340px;
      overflow:auto;
    }
    table.history {
      width:100%;
      border-collapse:collapse;
      font-size:10px;
      min-width:760px;
    }
    table.history th, table.history td {
      text-align:left;
      padding:6px 8px;
      border-bottom:1px solid #103624;
      white-space:nowrap;
    }
    table.history th { color:#7fe9b7; font-weight:normal; font-size:9px; }
    table.history tr.win td { color:#caffdf; }
    table.history tr.lose td { color:#ffd0d0; }

    .pfair {
      background:#081a13;
      border:2px dashed #275a41;
      border-radius:var(--radius);
      padding:14px;
      display:grid;
      gap:10px;
      font-size:11px;
    }
    .pfair code, .code-block {
      background:#03140e;
      border:1px solid #0f3b27;
      border-radius:10px;
      padding:8px 10px;
      font-size:10px;
      line-height:1.6;
      overflow:auto;
      color:#b8ffda;
      max-height:90px;
    }
    .tag {
      background:#0b2519;
      border:1px solid #1e5a3c;
      border-radius:8px;
      padding:3px 8px;
      font-size:9px;
      display:inline-block;
      color:#a9ffcf;
      letter-spacing:.5px;
    }

    .flex-row { display:flex; gap:14px; flex-wrap:wrap; align-items:center; }

    .content-section {
      margin-top:34px;
    }

    .divider {
      height:2px;
      background:linear-gradient(90deg,#39ff1400,#39ff1499,#39ff1400);
      margin:30px 0;
      border-radius:4px;
    }

    .inline-table {
      width:100%; border-collapse:collapse; font-size:10px; margin-top:8px;
    }
    .inline-table th, .inline-table td {
      border-bottom:1px solid #103624;
      padding:6px 8px;
      text-align:left;
      white-space:nowrap;
    }
    .inline-table th { color:#7fe9b7; font-weight:normal; font-size:9px; }

    .toast {
      position:fixed;
      bottom:18px; right:18px;
      background:#081a13;
      border:2px solid #144d35;
      padding:14px 18px;
      border-radius:var(--radius);
      font-size:11px;
      box-shadow:0 0 16px #39ff1433;
      display:none;
      max-width:300px;
      z-index:30;
    }

    /* Modal */
    .modal-backdrop {
      position:fixed; inset:0;
      background:#000c;
      backdrop-filter:blur(4px);
      display:none;
      align-items:center;
      justify-content:center;
      z-index:50;
      padding:30px 20px;
    }
    .modal {
      width:100%;
      max-width:760px;
      background:#0b1418;
      border:3px solid #123b27;
      border-radius:var(--radius-lg);
      padding:26px 24px 30px;
      box-shadow:0 0 44px #39ff1428, 0 14px 34px #000;
      position:relative;
      animation:pop .35s cubic-bezier(.16,.82,.33,1.12);
    }
    @keyframes pop {
      0% { transform:scale(.85) translateY(14px); opacity:.2; }
      100% { transform:scale(1) translateY(0); opacity:1; }
    }
    .modal h3 { margin:0 0 20px; font-size:18px; }
    .close-modal {
      position:absolute; top:10px; right:14px;
      background:#132e46; border:2px solid #1b4e6a;
      border-radius:10px; padding:6px 10px;
      font-size:10px; cursor:pointer;
      color:#caffdf;
      transition:.18s;
    }
    .close-modal:hover { background:#1b4e6a; }

    .path-steps {
      display:grid;
      gap:4px;
      grid-template-columns:repeat(auto-fill,minmax(120px,1fr));
      max-height:240px;
      overflow:auto;
      border:1px solid #134b31;
      border-radius:12px;
      padding:10px;
      background:#081a13;
      font-size:10px;
    }
    .path-step {
      padding:6px 6px 8px;
      background:#03140e;
      border:1px solid #0f3b27;
      border-radius:10px;
      display:flex;
      flex-direction:column;
      gap:4px;
      position:relative;
    }
    .path-step span.dir { font-size:11px; color:#caffdf; }
    .path-step span.hash { font-size:9px; color:#7fe9b7; word-break:break-all; }

    .warning-box {
      background:#2b1a07;
      border:2px solid #7a4e1e;
      border-radius:14px;
      padding:14px 16px;
      font-size:11px;
      line-height:1.8;
      box-shadow:0 0 12px #ffc34e33;
      color:#ffdca8;
    }

    .switch-row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-top:10px; }
    .switch {
      position:relative;
      display:inline-block;
      width:46px;
      height:24px;
    }
    .switch input { opacity:0; width:0; height:0; }
    .slider {
      position:absolute;
      inset:0;
      background:#0f2b1c;
      border:2px solid #1e5a3c;
      border-radius:999px;
      cursor:pointer;
      transition:.25s;
    }
    .slider:before {
      content:"";
      position:absolute;
      height:16px; width:16px;
      left:4px; top:2px;
      background:#39ff14;
      border-radius:50%;
      box-shadow:0 0 8px #39ff1466;
      transition:.25s;
    }
    .switch input:checked + .slider { background:#115034; }
    .switch input:checked + .slider:before { transform:translateX(20px); background:#00ffa5; }

    footer {
      margin-top:60px;
      padding:30px 10px 50px;
      text-align:center;
      font-size:9px;
      color:#7fe9b7;
      opacity:.75;
    }
  </style>
</head>
<body>
  <div class="container">
    <a href="../index.html#games" class="back-link">‚Üê Back to Casino</a>
    <h1>üéØ PBJ PLINKO (Improved Demo Version)</h1>

    <!-- HERO -->
    <div class="hero">
      <div class="hero-block">
        <h2 style="margin-top:0;font-size:20px;">Watch ‚Ä¢ Learn ‚Ä¢ Verify</h2>
        <p>
          This improved PBJ Plinko demo adds visual upgrades, hardened logic,
          burst mode, speed control, history export and step-by-step provably fair style verification.
        </p>
        <p style="color:#7fe9b7">
          Calibrated demo RTP ‚âà 99% (1% edge).<br/>
          Every left/right decision is derived from SHA-256:
          <code>serverSeed-clientSeed-nonce-step</code>.
        </p>
        <div class="warning-box">
          Educational demo only with fake balance. Bets and balance are not real tokens.
          This does not represent a production-ready distribution or audited economic model.
        </div>
      </div>
      <div class="hero-block">
        <div class="stats-bar">
          <div class="stat">
            <span class="label">Balance (demo)</span>
            <span class="value" id="balance">0</span>
          </div>
          <div class="stat">
            <span class="label">Drops left</span>
            <span class="value" id="playsLeft">0</span>
          </div>
          <div class="stat">
            <span class="label">W / L</span>
            <span class="value"><span id="wins">0</span> / <span id="losses">0</span></span>
          </div>
          <div class="stat">
            <span class="label">Demo RTP</span>
            <span class="value" id="rtp">99.00%</span>
          </div>
          <div class="stat">
            <span class="label">Nonce</span>
            <span class="value" id="nonce">0</span>
          </div>
        </div>
        <div class="switch-row">
          <label class="switch">
            <input type="checkbox" id="soundToggle" />
            <span class="slider"></span>
          </label>
          <small>Sound ON/OFF</small>
          <label class="switch">
            <input type="checkbox" id="animEnergy" checked />
            <span class="slider"></span>
          </label>
          <small>Advanced animation</small>
          <label class="switch">
            <input type="checkbox" id="probView" />
            <span class="slider"></span>
          </label>
          <small>Show probability table</small>
        </div>
        <div id="probabilities" style="display:none; margin-top:14px">
          <h3 style="font-size:14px;margin:0 0 8px;">Per-Slot Probabilities</h3>
          <div style="max-height:140px; overflow:auto; border:1px solid #134b31; border-radius:10px; padding:8px; background:#03140e">
            <table class="inline-table" id="probTable">
              <thead>
                <tr>
                  <th>Slot</th>
                  <th>P(%)</th>
                  <th>Multiplier</th>
                  <th>EV contrib.</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>
        </div>
      </div>
    </div>

    <!-- GAME + HISTORY -->
    <div class="grid-game">
      <div class="panel">
        <h2 style="margin-top:0;font-size:18px;">üéÆ Advanced Game Panel</h2>

        <div class="control-group">
          <div class="control" style="flex:1.4">
            <label for="bet">Bet (PBJ)</label>
            <div class="chips" style="margin-bottom:6px">
              <span class="chip" data-add="10">+10</span>
              <span class="chip" data-add="50">+50</span>
              <span class="chip" data-mul="2">x2</span>
              <span class="chip" data-half="1">1/2</span>
              <span class="chip" data-max="1">MAX</span>
            </div>
            <input type="number" id="bet" min="1" step="1" value="10" />
            <small>Balance: <span id="balance2">0</span> PBJ</small>
          </div>

          <div class="control">
            <label for="risk">Risk level</label>
            <select id="risk">
              <option value="low">Low</option>
              <option value="medium" selected>Medium</option>
              <option value="high">High</option>
              <option value="extreme">Extreme</option>
            </select>
            <small>Curves tuned and scaled to match global RTP.</small>
          </div>

          <div class="control">
            <label for="rows">Pin rows</label>
            <select id="rows">
              <option value="8">8</option>
              <option value="12" selected>12</option>
              <option value="16">16</option>
              <option value="20">20</option>
            </select>
            <small>More rows = more dispersion.</small>
          </div>

          <div class="control">
            <label for="multiCount">Burst mode (count)</label>
            <input type="number" id="multiCount" min="1" max="50" value="1" />
            <small>Sequential multi-drop.</small>
          </div>

          <div class="control">
            <label for="speedRange">Animation speed</label>
            <input type="range" id="speedRange" min="0.3" max="3" step="0.1" value="1.2" />
            <small><span id="speedLabel">1.2x</span> (affects per-row duration).</small>
          </div>
        </div>

        <div class="flex-row" style="margin-bottom:12px">
          <button class="btn primary" id="dropBtn">DROP</button>
          <button class="btn alt" id="autoBtn" data-running="0">Auto: OFF</button>
          <button class="btn soft" id="burstBtn">Burst</button>
          <button class="btn" id="verifyBtn">Verify Last</button>
          <button class="btn danger" id="resetBtn">Reset Demo</button>
        </div>

        <small style="display:block;margin-bottom:10px;color:#7fe9b7">
          Payout = bet √ó multiplier of the final slot. Treated as Win if multiplier &gt; 1.
        </small>

        <div class="board-wrap">
          <canvas id="board" width="1280" height="880" aria-label="PBJ Plinko improved board"></canvas>
          <div class="payouts" id="payouts"></div>
        </div>

        <div style="margin-top:16px; display:flex; flex-wrap:wrap; gap:12px">
          <button class="btn soft" id="exportBtn">Export History CSV</button>
          <button class="btn soft" id="seedCopyBtn">Copy Seeds</button>
          <button class="btn soft" id="regenClient">New Client Seed</button>
          <button class="btn soft" id="reseedServer">Re-seed Server</button>
        </div>
        <small style="margin-top:12px;display:block">
          ServerSeed: <code id="serverSeed"></code><br/>
          ClientSeed: <code id="clientSeed"></code>
        </small>
      </div>

      <div class="panel">
        <h2 style="margin-top:0;font-size:18px;">üìú History</h2>
        <div class="history-wrap">
          <table class="history" id="history">
            <thead>
              <tr>
                <th>Time</th>
                <th>Bet</th>
                <th>Risk</th>
                <th>Rows</th>
                <th>Slot</th>
                <th>Multiplier</th>
                <th>Result</th>
                <th>Balance</th>
                <th>Nonce</th>
              </tr>
            </thead>
            <tbody id="historyBody"></tbody>
          </table>
        </div>

        <h2 style="margin-top:24px;font-size:18px;">üß™ Provably Fair (Style)</h2>
        <div class="pfair">
          <div>
            <span class="tag">Server Seed (demo)</span>
            <code id="serverSeed2"></code>
          </div>
          <div>
            <span class="tag">Client Seed</span>
            <code id="clientSeed2"></code>
          </div>
          <div class="flex-row" style="margin-top:4px">
            <div class="stat" style="min-width:150px">
              <span class="label">Current Nonce</span>
              <span class="value" id="nonce2">0</span>
            </div>
            <div class="stat" style="min-width:150px">
              <span class="label">Last Slot</span>
              <span class="value" id="lastSlot">-</span>
            </div>
            <div class="stat" style="min-width:150px">
              <span class="label">Last Base Hash</span>
              <span class="value" id="lastBaseHash" style="font-size:10px; word-break:break-all;">-</span>
            </div>
          </div>
          <small style="color:#7fe9b7">
            Each step uses SHA-256(serverSeed-clientSeed-nonce-step). We take the first byte of the hash
            and if its value ‚â• 128 (0x80) the ball moves right; if &lt; 128 it moves left. You can inspect all steps in the modal.
          </small>
        </div>
      </div>
    </div>

    <div class="divider"></div>

    <div class="content-section">
      <h2 style="margin-top:0;font-size:18px;">üìã How to Play</h2>
      <ul style="font-size:11px;line-height:1.9;margin:0;padding-left:0;list-style:none">
        <li>Choose your bet.</li>
        <li>Select risk level and number of rows.</li>
        <li>Use DROP for a single ball, Burst for multiple, or Auto for continuous play.</li>
        <li>Verify the latest drop path using the provably-fair style modal.</li>
        <li>Export the full history to CSV if you want to analyse outcomes offline.</li>
      </ul>
    </div>

    <div class="content-section">
      <h2 style="margin-top:0;font-size:18px;">üéØ Risk Levels & Distributions</h2>
      <p style="font-size:11px;line-height:1.9">
        <strong>Low</strong>: multipliers are moderate and concentrated near the center for smoother variance.<br/>
        <strong>Medium</strong>: balanced exposure between center and extremes.<br/>
        <strong>High</strong>: much higher multipliers on the edges with more low-multiplier hits overall.<br/>
        <strong>Extreme</strong>: sharp peaks on extremes and a depressed center, delivering very high volatility.<br/>
        A final scaling step adjusts all multipliers so the overall RTP targets the configured value (1 ‚àí house edge).
      </p>
    </div>

    <div class="content-section">
      <h2 style="margin-top:0;font-size:18px;">üíé Enhanced Features</h2>
      <ul style="font-size:11px;line-height:1.9;margin:0;padding-left:0;list-style:none">
        <li>Per-step hash-driven left/right decisions.</li>
        <li>Verification modal showing hashes and directions for the last drop.</li>
        <li>Burst and auto modes with animation speed control.</li>
        <li>Optional probability view per slot with EV contribution.</li>
        <li>History export to CSV.</li>
        <li>Seed regeneration and clipboard copy helpers.</li>
        <li>Advanced animation with subtle bounces and jitter.</li>
        <li>Multiplier distribution colour-coded relative to risk and magnitude.</li>
      </ul>
    </div>

    <footer>PBJ Plinko educational demo ‚Ä¢ ¬© 2025 ‚Ä¢ No real economics implied ‚Ä¢ Improved version</footer>
  </div>

  <!-- Verification Modal -->
  <div class="modal-backdrop" id="verifyModal">
    <div class="modal">
      <button class="close-modal" data-close="1">Close ‚úï</button>
      <h3>üîê Last Drop Verification</h3>
      <p style="font-size:11px; line-height:1.8">
        Below you can inspect every step used to determine left / right decisions.
        Per-step formula:
        <code>SHA256(serverSeed-clientSeed-nonce-step)</code>.
        We take the first byte of the hash in hex; if its value ‚â• 128 (0x80) the ball goes <strong>RIGHT</strong>,
        otherwise it goes <strong>LEFT</strong>.
      </p>
      <div class="path-steps" id="pathSteps"></div>
      <div style="margin-top:18px">
        <small style="color:#7fe9b7">Final slot index = total number of steps that went RIGHT.</small>
      </div>
    </div>
  </div>

  <div class="toast" id="toast"></div>

  <script>
  ;(() => {
    const HOUSE_EDGE = 0.01; // 1% demo edge

    const state = {
      balance: 1000,
      playsLeft: 50,
      wins: 0,
      losses: 0,
      serverSeed: 'PBJ-PLINKO-DEMO-SEED-2025',
      clientSeed: '',
      nonce: 0,
      auto: false,
      dropping: false,
      rows: 12,
      risk: 'medium',
      payouts: [],
      history: [],
      lastPath: [],
      lastSlot: null,
      lastBaseHash: '',
      animAdvanced: true,
      sound: false,
      speedFactor: 1.2,
    };

    const el = {
      bet: document.getElementById('bet'),
      balance: document.getElementById('balance'),
      balance2: document.getElementById('balance2'),
      playsLeft: document.getElementById('playsLeft'),
      wins: document.getElementById('wins'),
      losses: document.getElementById('losses'),
      risk: document.getElementById('risk'),
      rows: document.getElementById('rows'),
      dropBtn: document.getElementById('dropBtn'),
      autoBtn: document.getElementById('autoBtn'),
      burstBtn: document.getElementById('burstBtn'),
      resetBtn: document.getElementById('resetBtn'),
      board: document.getElementById('board'),
      payouts: document.getElementById('payouts'),
      historyBody: document.getElementById('historyBody'),
      rtp: document.getElementById('rtp'),
      serverSeed: document.getElementById('serverSeed'),
      clientSeed: document.getElementById('clientSeed'),
      serverSeed2: document.getElementById('serverSeed2'),
      clientSeed2: document.getElementById('clientSeed2'),
      nonce: document.getElementById('nonce'),
      nonce2: document.getElementById('nonce2'),
      lastSlot: document.getElementById('lastSlot'),
      lastBaseHash: document.getElementById('lastBaseHash'),
      regenClient: document.getElementById('regenClient'),
      reseedServer: document.getElementById('reseedServer'),
      speedRange: document.getElementById('speedRange'),
      speedLabel: document.getElementById('speedLabel'),
      multiCount: document.getElementById('multiCount'),
      verifyBtn: document.getElementById('verifyBtn'),
      exportBtn: document.getElementById('exportBtn'),
      seedCopyBtn: document.getElementById('seedCopyBtn'),
      soundToggle: document.getElementById('soundToggle'),
      animEnergy: document.getElementById('animEnergy'),
      probView: document.getElementById('probView'),
      probabilities: document.getElementById('probabilities'),
      probTable: document.getElementById('probTable').querySelector('tbody'),
      toast: document.getElementById('toast'),
      verifyModal: document.getElementById('verifyModal'),
      pathSteps: document.getElementById('pathSteps'),
    };

    // Utils
    const fmt = (n, d=2) => Number(n).toLocaleString('en-US',{minimumFractionDigits:d,maximumFractionDigits:d});
    const nowTime = () => new Date().toLocaleTimeString([], {hour12:false});

    function clampBet() {
      let v = parseInt(el.bet.value || '0', 10);
      if (isNaN(v)) v = 1;
      if (v < 1) v = 1;
      if (v > state.balance) v = Math.max(1, Math.floor(state.balance));
      el.bet.value = String(v);
      return v;
    }

    function showToast(msg, timeout=2600) {
      el.toast.textContent = msg;
      el.toast.style.display = 'block';
      clearTimeout(el.toast._t);
      el.toast._t = setTimeout(()=>{ el.toast.style.display='none'; }, timeout);
    }

    function genClientSeed() {
      const r = crypto.getRandomValues(new Uint32Array(3));
      return `client-${r[0].toString(16)}${r[1].toString(16)}${r[2].toString(16)}`;
    }
    function genServerSeed() {
      const r = crypto.getRandomValues(new Uint32Array(4));
      return `server-${r[0].toString(16)}-${r[1].toString(16)}-${r[2].toString(16)}-${r[3].toString(16)}`;
    }

    async function sha256Hex(str) {
      const buf = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(str));
      return Array.from(new Uint8Array(buf)).map(b=>b.toString(16).padStart(2,'0')).join('');
    }

    // Binomial
    function nCk(n,k){ if(k<0||k>n)return 0; if(k===0||k===n)return 1; k=Math.min(k,n-k); let r=1; for(let i=1;i<=k;i++){ r=r*(n-k+i)/i; } return r; }
    function binomialProb(n,k){ return nCk(n,k)/Math.pow(2,n); }

    // Payouts curve
    function buildPayouts(rows, risk) {
      const cfg = {
        low:     { a:1.0,  b:2.6, c:0.10, v:0.15 },
        medium:  { a:2.4,  b:2.0, c:0.18, v:0.32 },
        high:    { a:7.2,  b:1.6, c:0.30, v:0.55 },
        extreme: { a:12.5, b:1.45,c:0.38, v:0.85 },
      }[risk];
      const slots = rows + 1;
      const center = rows / 2;
      const raw = [];
      for (let i=0;i<slots;i++){
        const dist = Math.abs(i-center)/(rows/2); // 0..1
        let m = 1 + cfg.a * Math.pow(dist, cfg.b) - cfg.c * Math.pow(1 - dist, 2);
        const extremeFactor = Math.pow(dist, 1.4) * cfg.v;
        m += extremeFactor;
        m = Math.max(0.05, m);
        raw.push(m);
      }
      let EV = 0;
      for(let i=0;i<slots;i++){ EV += binomialProb(rows,i)*raw[i]; }
      const scale = (1 - HOUSE_EDGE)/EV;
      const payouts = raw.map(v => Math.max(0.01, Math.round(v*scale*100)/100));
      return payouts;
    }

    // Path generation: {steps, hashes, slot}
    async function generatePath(rows) {
      const hashes = [];
      let rights = 0;
      for (let step=0; step<rows; step++) {
        const base = `${state.serverSeed}-${state.clientSeed}-${state.nonce}-${step}`;
        const h = await sha256Hex(base);
        hashes.push({ base, hash:h });
        const firstByte = parseInt(h.slice(0,2),16);
        const moveRight = firstByte >= 0x80;
        if (moveRight) rights++;
      }
      const steps = hashes.map(h => (parseInt(h.hash.slice(0,2),16) >= 0x80 ? 1 : 0));
      return { steps, hashes, slot: rights };
    }

    // Canvas / animation
    const ctx = el.board.getContext('2d');

    function resizeCanvas(){
      const dpr = window.devicePixelRatio || 1;
      const cssW = el.board.clientWidth;
      const cssH = el.board.clientHeight;
      el.board.width = Math.floor(cssW * dpr);
      el.board.height = Math.floor(cssH * dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);
      drawBoard();
    }

    function drawBoard(ball){
      const w = el.board.clientWidth;
      const h = el.board.clientHeight;
      ctx.clearRect(0,0,w,h);
      const rows = state.rows;
      const paddingX = 28;
      const top = 30;
      const bottomSpace = 94;
      const usableW = w - paddingX*2;
      const usableH = h - top - bottomSpace;

      // pins
      ctx.fillStyle = '#12442d';
      for (let r=0; r<rows; r++){
        const y = top + usableH * (r+1)/(rows+1);
        const count = r+1;
        const gap = usableW/rows;
        const rowWidth = (count-1)*gap;
        const startX = paddingX + (usableW-rowWidth)/2;
        for (let i=0;i<count;i++){
          const x = startX + i*gap;
          ctx.beginPath();
          ctx.arc(x,y,3,0,Math.PI*2);
          ctx.fill();
        }
      }

      // side walls
      ctx.strokeStyle = '#1e5a3c';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(paddingX, top);
      ctx.lineTo(paddingX, h - bottomSpace + 8);
      ctx.moveTo(w - paddingX, top);
      ctx.lineTo(w - paddingX, h - bottomSpace + 8);
      ctx.stroke();

      // slots
      const gap = usableW/rows;
      const baseY = h - bottomSpace + 10;
      ctx.strokeStyle = '#0f3b27';
      ctx.lineWidth = 1;
      for (let s=0; s<=rows; s++){
        const x = paddingX + s*gap;
        ctx.beginPath();
        ctx.moveTo(x, baseY);
        ctx.lineTo(x, baseY + 46);
        ctx.stroke();
      }
      ctx.fillStyle = '#0b2519';
      ctx.fillRect(paddingX, baseY+46, usableW, 8);

      // ball
      if (ball){
        const grd = ctx.createRadialGradient(ball.x, ball.y, 2, ball.x, ball.y, 14);
        grd.addColorStop(0, '#39ff14');
        grd.addColorStop(1, '#0c2d20');
        ctx.fillStyle = grd;
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, 10, 0, Math.PI*2);
        ctx.fill();
      }
    }

    function renderPayoutLabels(){
      const rows = state.rows;
      const slots = rows + 1;
      el.payouts.innerHTML = '';
      const max = Math.max(...state.payouts);
      for (let i=0;i<slots;i++){
        const v = state.payouts[i];
        const d = document.createElement('div');
        d.className = 'payout';
        const ratio = v / max;
        const hue = 120 - Math.round(ratio * 90);
        d.innerHTML = `<span class="x" style="box-shadow:0 0 10px rgba(${hue},255,80,0.25);">${v.toFixed(2)}x</span>`;
        el.payouts.appendChild(d);
      }
    }

    function updateProbTable(){
      if (!el.probView.checked){
        el.probabilities.style.display='none';
        return;
      }
      el.probabilities.style.display='block';
      el.probTable.innerHTML='';
      const rows = state.rows;
      let EV = 0;
      for (let i=0;i<=rows;i++){
        const p = binomialProb(rows,i);
        const mult = state.payouts[i];
        const contrib = p * mult;
        EV += contrib;
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${i}</td>
          <td>${(p*100).toFixed(3)}%</td>
          <td>${mult.toFixed(2)}x</td>
          <td>${contrib.toFixed(4)}</td>
        `;
        el.probTable.appendChild(tr);
      }
      el.rtp.textContent = `${((1 - HOUSE_EDGE)*100).toFixed(2)}%`;
    }

    function updateTopline(){
      el.balance.textContent = fmt(state.balance,0);
      el.balance2.textContent = fmt(state.balance,0);
      el.playsLeft.textContent = state.playsLeft;
      el.wins.textContent = state.wins;
      el.losses.textContent = state.losses;
      el.serverSeed.textContent = state.serverSeed;
      el.clientSeed.textContent = state.clientSeed;
      el.serverSeed2.textContent = state.serverSeed;
      el.clientSeed2.textContent = state.clientSeed;
      el.nonce.textContent = state.nonce;
      el.nonce2.textContent = state.nonce;
      clampBet();
      el.dropBtn.disabled = state.dropping || state.playsLeft <= 0 || state.balance < 1;
    }

    function addHistoryEntry(entry){
      state.history.unshift(entry);
      const tr = document.createElement('tr');
      tr.className = entry.win ? 'win' : 'lose';
      tr.innerHTML = `
        <td>${entry.time}</td>
        <td>${fmt(entry.bet,0)}</td>
        <td>${entry.risk}</td>
        <td>${entry.rows}</td>
        <td>${entry.slot}</td>
        <td>${entry.mult.toFixed(2)}x</td>
        <td>${entry.win ? '+'+fmt(entry.payout,2) : '-'+fmt(entry.bet,2)}</td>
        <td>${fmt(entry.balance,0)}</td>
        <td>${entry.nonce}</td>
      `;
      el.historyBody.prepend(tr);
    }

    function exportCSV(){
      if (state.history.length === 0){
        showToast('No history to export.');
        return;
      }
      const header = ['time','bet','risk','rows','slot','multiplier','payout','win','balance','nonce'];
      const rows = state.history.map(h=>[
        h.time,
        h.bet,
        h.risk,
        h.rows,
        h.slot,
        h.mult.toFixed(2),
        h.payout.toFixed(2),
        h.win ? 1 : 0,
        h.balance,
        h.nonce
      ]);
      const csv = [header.join(','), ...rows.map(r=>r.join(','))].join('\n');
      const blob = new Blob([csv], {type:'text/csv'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'plinko_history_demo.csv';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
      showToast('CSV exported.');
    }

    async function copySeeds(){
      const text = `ServerSeed=${state.serverSeed}\nClientSeed=${state.clientSeed}\nNonce=${state.nonce}`;
      try {
        await navigator.clipboard.writeText(text);
        showToast('Seeds copied to clipboard.');
      } catch {
        showToast('Unable to copy seeds (clipboard blocked?).');
      }
    }

    function saveLocal(){
      const data = {
        balance: state.balance,
        playsLeft: state.playsLeft,
        wins: state.wins,
        losses: state.losses,
        serverSeed: state.serverSeed,
        clientSeed: state.clientSeed,
        nonce: state.nonce,
        risk: state.risk,
        rows: state.rows
      };
      localStorage.setItem('pbj_plinko_demo', JSON.stringify(data));
    }

    function loadLocal(){
      try {
        const raw = localStorage.getItem('pbj_plinko_demo');
        if (!raw) return;
        const d = JSON.parse(raw);
        if (typeof d !== 'object' || !d) return;
        ['balance','playsLeft','wins','losses','serverSeed','clientSeed','nonce','risk','rows'].forEach(k=>{
          if (k in d) state[k] = d[k];
        });
      } catch {}
      if (!state.clientSeed) state.clientSeed = genClientSeed();
    }

    // Animation for one drop
    async function runDrop(bet){
      const ctxW = el.board.clientWidth;
      const ctxH = el.board.clientHeight;
      const rows = state.rows;
      const paddingX = 28;
      const top = 30;
      const bottomSpace = 94;
      const usableW = ctxW - paddingX*2;
      const usableH = ctxH - top - bottomSpace;
      const gapX = usableW/rows;

      const path = await generatePath(rows);
      state.lastPath = path.hashes;
      state.lastSlot = path.slot;
      state.lastBaseHash = path.hashes.length ? path.hashes[0].hash : '';
      el.lastSlot.textContent = path.slot;
      el.lastBaseHash.textContent = state.lastBaseHash || '-';

      let x = paddingX + usableW/2;
      let y = top;
      const baseDelay = 260 / state.speedFactor;
      const framesPerRow = state.animAdvanced ? 16 : 8;

      for (let r=0; r<rows; r++){
        const moveRight = path.steps[r] === 1;
        const targetX = x + (moveRight ? gapX/2 : -gapX/2);
        const targetY = top + usableH * (r+1)/(rows+1);
        for (let f=0; f<framesPerRow; f++){
          const t = (f+1)/framesPerRow;
          const ease = t*t*(3-2*t);
          let jitterX = 0;
          let jitterY = 0;
          if (state.animAdvanced){
            jitterX = (Math.random()-0.5)*2;
            jitterY = (Math.random()-0.5)*2;
          }
          const cx = x + (targetX-x)*ease + jitterX;
          const cy = y + (targetY-y)*ease + jitterY;
          drawBoard({x:cx,y:cy});
          await new Promise(res=>setTimeout(res, baseDelay/framesPerRow));
        }
        x = targetX;
        y = targetY;
      }
      const baseY = ctxH - bottomSpace + 10 + 46 - 10;
      drawBoard({x, y:baseY});
      return path.slot;
    }

    async function doSingleDrop(){
      if (state.dropping) return;
      const bet = clampBet();
      if (state.playsLeft <= 0){
        showToast('No drops left.');
        return;
      }
      if (bet > state.balance){
        showToast('Not enough balance for that bet.');
        return;
      }
      state.dropping = true;
      state.playsLeft = Math.max(0, state.playsLeft - 1);
      state.balance = Math.max(0, state.balance - bet);
      state.nonce += 1;
      saveLocal();
      updateTopline();

      const slot = await runDrop(bet);
      const mult = state.payouts[slot];
      const payout = bet * mult;
      state.balance = Math.max(0, state.balance + payout);

      const win = mult > 1;
      if (win) state.wins += 1; else state.losses += 1;

      el.payouts.querySelectorAll('.payout').forEach((d,idx)=>{
        d.classList.toggle('highlight', idx===slot);
      });

      addHistoryEntry({
        time: nowTime(),
        bet,
        risk: state.risk,
        rows: state.rows,
        slot,
        mult,
        payout,
        win,
        balance: state.balance,
        nonce: state.nonce
      });

      state.dropping = false;
      saveLocal();
      updateTopline();
    }

    async function runBurst(){
      const count = Math.max(1, Math.min(50, parseInt(el.multiCount.value || '1',10)));
      for (let i=0;i<count;i++){
        if (state.playsLeft <= 0 || state.balance < 1) break;
        await doSingleDrop();
        if (state.auto === false && i < count-1){
          await new Promise(res=>setTimeout(res, 250));
        }
      }
    }

    function toggleAuto(){
      state.auto = !state.auto;
      el.autoBtn.textContent = `Auto: ${state.auto ? 'ON' : 'OFF'}`;
      if (!state.auto) return;
      const loop = async () => {
        if (!state.auto) return;
        if (state.playsLeft <= 0 || state.balance <= 0){
          state.auto = false;
          el.autoBtn.textContent = 'Auto: OFF';
          return;
        }
        await doSingleDrop();
        if (state.auto){
          setTimeout(loop, 200);
        }
      };
      loop();
    }

    function showVerifyModal(){
      if (!state.lastPath || state.lastPath.length === 0){
        showToast('No drop history to verify yet.');
        return;
      }
      el.pathSteps.innerHTML = '';
      state.lastPath.forEach((item, idx)=>{
        const firstByte = parseInt(item.hash.slice(0,2),16);
        const dir = firstByte >= 0x80 ? 'RIGHT' : 'LEFT';
        const div = document.createElement('div');
        div.className = 'path-step';
        div.innerHTML = `
          <span class="dir">Step ${idx+1}: <strong>${dir}</strong> (byte=${firstByte})</span>
          <span class="hash">${item.base}</span>
          <span class="hash">${item.hash}</span>
        `;
        el.pathSteps.appendChild(div);
      });
      el.verifyModal.style.display = 'flex';
    }

    function closeVerifyModal(){
      el.verifyModal.style.display = 'none';
    }

    function resetDemo(){
      if (!confirm('Reset Plinko demo (balance, stats and seeds)?')) return;
      state.balance = 1000;
      state.playsLeft = 50;
      state.wins = 0;
      state.losses = 0;
      state.nonce = 0;
      state.history = [];
      el.historyBody.innerHTML = '';
      state.lastPath = [];
      state.lastSlot = null;
      state.lastBaseHash = '';
      el.lastSlot.textContent = '-';
      el.lastBaseHash.textContent = '-';
      state.dropping = false;
      state.auto = false;
      el.autoBtn.textContent = 'Auto: OFF';
      saveLocal();
      updateTopline();
      drawBoard();
      showToast('Demo reset.');
    }

    function attachEvents(){
      el.bet.addEventListener('input', updateTopline);
      el.risk.addEventListener('change', () => {
        state.risk = el.risk.value;
        state.payouts = buildPayouts(state.rows, state.risk);
        renderPayoutLabels();
        updateProbTable();
        saveLocal();
      });
      el.rows.addEventListener('change', () => {
        state.rows = parseInt(el.rows.value,10);
        state.payouts = buildPayouts(state.rows, state.risk);
        renderPayoutLabels();
        updateProbTable();
        resizeCanvas();
        saveLocal();
      });
      document.querySelectorAll('.chip').forEach(ch=>{
        ch.addEventListener('click', ()=>{
          let v = parseInt(el.bet.value || '0', 10);
          if (ch.dataset.add) v += parseInt(ch.dataset.add,10);
          if (ch.dataset.mul) v = Math.ceil(v * parseFloat(ch.dataset.mul));
          if (ch.dataset.half) v = Math.max(1, Math.floor(v/2));
          if (ch.dataset.max) v = Math.max(1, Math.floor(state.balance));
          el.bet.value = String(v);
          updateTopline();
        });
      });
      el.dropBtn.addEventListener('click', doSingleDrop);
      el.burstBtn.addEventListener('click', runBurst);
      el.autoBtn.addEventListener('click', toggleAuto);
      el.resetBtn.addEventListener('click', resetDemo);
      el.verifyBtn.addEventListener('click', showVerifyModal);
      el.exportBtn.addEventListener('click', exportCSV);
      el.seedCopyBtn.addEventListener('click', copySeeds);
      el.soundToggle.addEventListener('change', () => {
        state.sound = el.soundToggle.checked;
      });
      el.animEnergy.addEventListener('change', () => {
        state.animAdvanced = el.animEnergy.checked;
      });
      el.probView.addEventListener('change', updateProbTable);
      el.speedRange.addEventListener('input', () => {
        state.speedFactor = parseFloat(el.speedRange.value);
        el.speedLabel.textContent = `${state.speedFactor.toFixed(1)}x`;
      });
      el.regenClient.addEventListener('click', () => {
        state.clientSeed = genClientSeed();
        state.nonce = 0;
        saveLocal();
        updateTopline();
        showToast('Client seed regenerated.');
      });
      el.reseedServer.addEventListener('click', () => {
        state.serverSeed = genServerSeed();
        state.nonce = 0;
        saveLocal();
        updateTopline();
        showToast('Server seed regenerated.');
      });
      document.querySelectorAll('.close-modal').forEach(btn=>{
        btn.addEventListener('click', closeVerifyModal);
      });
      el.verifyModal.addEventListener('click', (e)=>{
        if (e.target === el.verifyModal) closeVerifyModal();
      });
      window.addEventListener('resize', resizeCanvas);
    }

    function init(){
      loadLocal();
      el.risk.value = state.risk;
      el.rows.value = String(state.rows);
      state.payouts = buildPayouts(state.rows, state.risk);
      resizeCanvas();
      renderPayoutLabels();
      updateProbTable();
      updateTopline();
      attachEvents();
    }

    init();
  })();
  </script>
</body>
</html>
