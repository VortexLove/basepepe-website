<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Plinko - Pepe Blackjack Casino</title>
  <meta name="description" content="Juega al Plinko en el casino PBJ. Ca√≠da de fichas y multiplicadores emocionantes." />
  
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com" crossorigin />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet" />
  
  <style>
    :root { color-scheme: dark; scroll-behavior:smooth; }
    html, body { margin:0; padding:0; background:#000; }
    html, body, * { font-family:'Press Start 2P', cursive !important; }
    body { -webkit-font-smoothing:antialiased; text-rendering:optimizeLegibility; }
    img { max-width:100%; height:auto; display:block; }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 40px 20px;
    }

    .back-link {
      display: inline-block;
      background:#0f2b1c;
      color:#a9ffcf;
      border:2px solid #1e5a3c;
      padding:10px 16px;
      border-radius:8px;
      text-decoration:none;
      font-size:12px;
      margin-bottom:30px;
      box-shadow:0 0 8px #39ff1433, 2px 2px 0 #001c0d;
      transition:transform .15s, box-shadow .15s;
    }
    .back-link:hover {
      transform:translateY(-3px);
      box-shadow:0 0 14px #39ff14, 4px 4px 0 #001c0d;
    }

    h1 {
      color:#39ff14;
      text-shadow:0 0 10px #39ff14;
      font-size:28px;
      margin-bottom:30px;
      text-align:center;
    }

    .hero-section {
      background:#0a1114;
      border-radius:20px;
      padding:30px;
      box-shadow:0 0 0 3px #0d1e15 inset, 0 14px 30px rgba(0,0,0,.6), 0 0 42px #39ff1428;
      border:3px solid #123b27;
      margin-bottom:40px;
      position:relative;
    }
    .hero-section::before {
      content:"";
      position:absolute;
      inset:-3px;
      border-radius:22px;
      z-index:-1;
      background:conic-gradient(from 0deg,#39ff14,#00ffa5,#39ff14);
      filter:blur(18px);
      opacity:.18;
    }

    .hero-image {
      width:100%;
      border-radius:12px;
      border:2px solid #1e5a3c;
      box-shadow:inset 0 0 16px #0c2d20, 0 10px 30px #000000aa, 0 0 24px #39ff1422;
      margin-bottom:25px;
      background:#071610;
      min-height:160px;
      display:flex;
      align-items:center;
      justify-content:center;
      color:#39ff14;
      font-size:14px;
      padding:16px;
      text-align:center;
    }

    .content-section {
      background:#0a1114;
      border-radius:20px;
      padding:28px 24px;
      box-shadow:0 0 0 3px #0d1e15 inset, 0 14px 30px rgba(0,0,0,.6), 0 0 42px #39ff1428;
      border:3px solid #123b27;
      margin-bottom:30px;
    }

    h2 {
      color:#39ff14;
      font-size:18px;
      margin-bottom:18px;
      text-shadow:0 0 6px #39ff14;
    }

    p, li, label, input, select, button, small {
      color:#b8ffda;
      font-size:12px;
      line-height:1.8;
    }

    ul {
      list-style:none;
      padding:0;
    }

    ul li::before {
      content:"‚Ä¢ ";
      color:#39ff14;
      font-weight:bold;
      margin-right:8px;
    }

    .game-grid {
      display:grid;
      gap:18px;
      grid-template-columns: 1fr;
    }
    @media(min-width: 980px){
      .game-grid {
        grid-template-columns: 1.1fr 0.9fr;
      }
    }

    .panel {
      background:#081014;
      border:2px solid #12442d;
      border-radius:16px;
      padding:18px;
      box-shadow:inset 0 0 12px #06130f, 0 0 24px #39ff141c;
    }

    .row {
      display:flex;
      gap:12px;
      flex-wrap:wrap;
      align-items:center;
      margin-bottom:12px;
    }
    .row > * { flex:1; min-width: 120px; }

    .control {
      display:flex;
      flex-direction:column;
      gap:6px;
      background:#061a12;
      border:1px solid #0f3b27;
      border-radius:12px;
      padding:10px 12px;
    }
    .control input[type="number"],
    .control select,
    .control input[type="range"] {
      background:#03140e;
      border:1px solid #0f3b27;
      border-radius:8px;
      padding:10px 12px;
      color:#b8ffda;
      outline:none;
      box-shadow:inset 0 0 8px #0000007a;
    }

    .stat {
      background:#061a12;
      border:1px solid #0f3b27;
      border-radius:12px;
      padding:10px 12px;
      display:flex;
      flex-direction:column;
      gap:4px;
    }
    .stat .label { color:#7fe9b7; font-size:10px; opacity:.9; }
    .stat .value { color:#39ff14; font-size:14px; text-shadow:0 0 6px #39ff1466; }

    .btn {
      display:inline-flex; align-items:center; justify-content:center;
      gap:8px;
      background:#0f2b1c;
      color:#a9ffcf;
      border:2px solid #1e5a3c;
      padding:12px 16px;
      border-radius:12px;
      text-decoration:none;
      font-size:12px;
      cursor:pointer;
      box-shadow:0 0 8px #39ff1433, 2px 2px 0 #001c0d;
      transition:transform .12s, box-shadow .12s, background .12s, opacity .12s;
      user-select:none;
    }
    .btn:hover { transform:translateY(-2px); box-shadow:0 0 14px #39ff14, 4px 4px 0 #001c0d; }
    .btn:disabled { opacity:.5; cursor:not-allowed; transform:none; box-shadow:none; }
    .btn.primary { background:#103c2a; border-color:#1e6a48; color:#caffdf; }
    .btn.danger { background:#2a1210; border-color:#6a1e1e; color:#ffd0d0; }

    .board-wrap {
      background:#061a12;
      border:1px solid #0f3b27;
      border-radius:12px;
      padding:12px;
    }
    canvas#board {
      width:100%;
      height:440px;
      display:block;
      background: radial-gradient(120% 120% at 50% 0%, #0c1f17 0%, #071a12 45%, #06160f 100%);
      border:2px solid #1e5a3c;
      border-radius:12px;
      box-shadow:inset 0 0 16px #0c2d20, 0 10px 30px #000000aa, 0 0 24px #39ff1422;
    }

    .chips {
      display:flex; gap:8px; flex-wrap:wrap;
    }
    .chip {
      background:#0b2519;
      border:1px dashed #2a7a55;
      color:#a9ffcf;
      padding:8px 10px;
      border-radius:999px;
      cursor:pointer;
      transition:transform .1s, box-shadow .1s;
      box-shadow:0 0 8px #39ff1420;
      user-select:none;
    }
    .chip:hover { transform:translateY(-1px); box-shadow:0 0 12px #39ff1455; }

    .payouts {
      display:flex; gap:6px; justify-content:space-between; align-items:flex-end; margin-top:10px;
    }
    .payout {
      flex:1; text-align:center;
      color:#a9ffcf; font-size:10px;
    }
    .payout .x {
      display:inline-block; padding:2px 4px; border-radius:6px; border:1px solid #1e5a3c; background:#0b2519;
    }

    .scroll {
      max-height:320px; overflow:auto; border:1px solid #0f3b27; border-radius:12px; padding:8px;
      background:#061a12;
    }

    table.history {
      width:100%; border-collapse:collapse; margin-top:8px;
      font-size:11px;
    }
    table.history th, table.history td {
      border-bottom:1px solid #103624;
      padding:8px 6px; text-align:left; color:#b8ffda;
      white-space:nowrap;
    }
    table.history th { color:#7fe9b7; font-weight:normal; }
    table.history tr.win td { color:#caffdf; }
    table.history tr.lose td { color:#ffd0d0; }

    .pfair {
      background:#061a12;
      border:1px dashed #275a41;
      border-radius:12px;
      padding:12px;
      display:grid; gap:8px;
    }
    .pfair code {
      background:#03140e; border:1px solid #0f3b27; border-radius:8px; padding:6px 8px; display:block; overflow:auto;
      color:#b8ffda;
    }
    .tag {
      background:#0b2519; border:1px solid #1e5a3c; border-radius:8px; padding:2px 6px; color:#a9ffcf; font-size:10px;
    }

    .coming-soon { display:none; }
  </style>
</head>
<body>
  <div class="container">
    <a href="../index.html#casino" class="back-link">‚Üê Volver al Casino</a>
    
    <h1>üéØ PLINKO</h1>

    <div class="hero-section">
      <div class="hero-image">
        Demo de Plinko PBJ: juega con saldo ficticio, sin blockchain ni tokens reales. Provably fair de muestra.
      </div>
      
      <h2>Observa la Ficha Caer y Ganar</h2>
      <p>
        Suelta fichas desde la parte superior del tablero y obs√©rvalas rebotar a trav√©s de los pines hasta
        aterrizar en un multiplicador. Los multiplicadores dependen del nivel de riesgo y el n√∫mero de filas.
        RTP demo: 99% aproximadamente (1% de edge).
      </p>
    </div>

    <div class="game-grid">
      <!-- LADO IZQUIERDO: JUEGO -->
      <div class="panel">
        <h2>üéÆ Panel de Juego</h2>

        <div class="row">
          <div class="control" style="flex:1.3">
            <label for="bet">Apuesta (PBJ)</label>
            <div class="row" style="gap:8px">
              <input type="number" id="bet" min="1" step="1" value="10" />
              <div class="chips">
                <span class="chip" data-add="10">+10</span>
                <span class="chip" data-add="50">+50</span>
                <span class="chip" data-mul="2">x2</span>
                <span class="chip" data-half="1">1/2</span>
                <span class="chip" data-max="1">MAX</span>
              </div>
            </div>
            <small class="muted">Saldo demo: <span id="balance">1000</span> PBJ ‚Ä¢ Tiradas restantes: <span id="playsLeft">50</span></small>
          </div>

          <div class="control">
            <label for="risk">Riesgo</label>
            <select id="risk">
              <option value="low">Bajo</option>
              <option value="medium" selected>Medio</option>
              <option value="high">Alto</option>
            </select>
          </div>

          <div class="control">
            <label for="rows">Filas de pines</label>
            <select id="rows">
              <option value="8">8</option>
              <option value="12" selected>12</option>
              <option value="16">16</option>
            </select>
          </div>
        </div>

        <div class="row">
          <div class="stat">
            <span class="label">RTP (demo)</span>
            <span class="value" id="rtp">99.00%</span>
          </div>
          <div class="stat">
            <span class="label">Registro</span>
            <span class="value"><span id="wins">0</span> W / <span id="losses">0</span> L</span>
          </div>
          <div class="stat">
            <span class="label">Semillas/Nonce</span>
            <span class="value">N: <span id="nonce">0</span></span>
          </div>
        </div>

        <div class="board-wrap">
          <canvas id="board" width="1280" height="880" aria-label="Tablero Plinko"></canvas>
          <div class="payouts" id="payouts"></div>
        </div>

        <div class="row" style="margin-top:14px">
          <button class="btn primary" id="dropBtn">DROP</button>
          <button class="btn" id="autoBtn" data-running="0">Auto-drop: OFF</button>
          <button class="btn danger" id="resetBtn">Reiniciar Demo</button>
        </div>
        <small class="muted">Nota: En demo, el pago es bet √ó multiplicador del slot alcanzado.</small>
      </div>

      <!-- LADO DERECHO: HISTORIAL + PROVABLY FAIR -->
      <div class="panel">
        <h2>üìú Historial</h2>
        <div class="scroll">
          <table class="history" id="history">
            <thead>
              <tr>
                <th>Hora</th>
                <th>Bet</th>
                <th>Riesgo</th>
                <th>Filas</th>
                <th>Slot</th>
                <th>Multi</th>
                <th>Res</th>
                <th>Saldo</th>
              </tr>
            </thead>
            <tbody id="historyBody"></tbody>
          </table>
        </div>

        <h2 style="margin-top:18px">üß™ Provably Fair (Demo)</h2>
        <div class="pfair">
          <div>
            <span class="tag">Server seed (fijo demo)</span>
            <code id="serverSeed"></code>
          </div>
          <div>
            <span class="tag">Client seed</span>
            <code id="clientSeed"></code>
          </div>
          <div class="row" style="margin:0">
            <button class="btn" id="regenClient">Regenerar client seed</button>
            <div class="stat" style="min-width:160px">
              <span class="label">Nonce</span>
              <span class="value" id="nonce2">0</span>
            </div>
          </div>
          <small class="muted">
            Cada ca√≠da usa SHA-256 de "serverSeed-clientSeed-nonce-step". Los pasos determinan izquierda/derecha.
            Puedes verificar recalculando los bits y el slot final (n√∫mero de derechos).
          </small>
        </div>
      </div>
    </div>

    <div class="content-section" style="margin-top:30px">
      <h2>üìã C√≥mo Jugar</h2>
      <ul>
        <li>Elige tu apuesta en tokens PBJ (demo)</li>
        <li>Selecciona riesgo (Bajo/Medio/Alto) y filas (8/12/16)</li>
        <li>Presiona DROP o activa Auto-drop</li>
        <li>Si la ficha cae en un multiplicador alto, ¬°ganas m√°s!</li>
      </ul>
    </div>

    <div class="content-section">
      <h2>üéØ Niveles de Riesgo</h2>
      <p>
        Bajo: pagos m√°s estables cerca del centro. Medio: balanceado. Alto: extremos
        grandes con mayor probabilidad de multiplicadores bajos. El RTP demo est√°
        calibrado al 99% para cualquier combinaci√≥n.
      </p>
    </div>

    <div class="content-section">
      <h2>üíé Caracter√≠sticas Especiales (Demo)</h2>
      <ul>
        <li>Animaci√≥n fluida de ca√≠da</li>
        <li>Provably-fair demostrativo (server/client seed + nonce)</li>
        <li>Auto-drop</li>
        <li>Historial y estad√≠sticas</li>
      </ul>
    </div>
  </div>

  <script>
    ;(() => {
      const HOUSE_EDGE = 0.01; // 1% edge demo
      const state = {
        balance: 1000,
        playsLeft: 50,
        wins: 0,
        losses: 0,
        serverSeed: 'PBJ-PLINKO-DEMO-SEED-2025',
        clientSeed: '',
        nonce: 0,
        auto: false,
        dropping: false,
        rows: 12,
        risk: 'medium',
        payouts: [],
      };

      const el = {
        bet: document.getElementById('bet'),
        balance: document.getElementById('balance'),
        playsLeft: document.getElementById('playsLeft'),
        risk: document.getElementById('risk'),
        rows: document.getElementById('rows'),
        dropBtn: document.getElementById('dropBtn'),
        autoBtn: document.getElementById('autoBtn'),
        resetBtn: document.getElementById('resetBtn'),
        board: document.getElementById('board'),
        payouts: document.getElementById('payouts'),
        historyBody: document.getElementById('historyBody'),
        wins: document.getElementById('wins'),
        losses: document.getElementById('losses'),
        rtp: document.getElementById('rtp'),
        serverSeed: document.getElementById('serverSeed'),
        clientSeed: document.getElementById('clientSeed'),
        nonce: document.getElementById('nonce'),
        nonce2: document.getElementById('nonce2'),
        regenClient: document.getElementById('regenClient'),
      };

      // Utils
      const fmt = (n, d=2) => Number(n).toLocaleString('es-ES', {minimumFractionDigits:d, maximumFractionDigits:d});
      const nowTime = () => new Date().toLocaleTimeString([], {hour12:false});
      function clampBet() {
        const max = state.balance;
        let v = parseInt(el.bet.value || '0', 10);
        if (v < 1) v = 1;
        if (v > max) v = Math.max(1, Math.floor(max));
        el.bet.value = String(v);
        return v;
      }

      // Storage
      function load() {
        try {
          const saved = JSON.parse(localStorage.getItem('pbj_plinko_demo') || '{}');
          if (saved && typeof saved === 'object') {
            ['balance','playsLeft','wins','losses','clientSeed','nonce','rows','risk'].forEach(k => {
              if (k in saved) state[k] = saved[k];
            });
          }
        } catch {}
        if (!state.clientSeed) state.clientSeed = genClientSeed();
      }
      function save() {
        const data = {
          balance: state.balance,
          playsLeft: state.playsLeft,
          wins: state.wins,
          losses: state.losses,
          clientSeed: state.clientSeed,
          nonce: state.nonce,
          rows: state.rows,
          risk: state.risk,
        };
        localStorage.setItem('pbj_plinko_demo', JSON.stringify(data));
      }
      function genClientSeed() {
        const r = crypto.getRandomValues(new Uint32Array(3));
        return `client-${r[0].toString(16)}${r[1].toString(16)}${r[2].toString(16)}`;
      }

      // Provably fair RNG via SHA-256
      async function sha256Hex(str) {
        const enc = new TextEncoder().encode(str);
        const buf = await crypto.subtle.digest('SHA-256', enc);
        const byteArray = Array.from(new Uint8Array(buf));
        return byteArray.map(b => b.toString(16).padStart(2, '0')).join('');
      }
      // Produce an array of floats [0,1) using hash blocks
      async function fairFloats(count) {
        const floats = [];
        let index = 0;
        while (floats.length < count) {
          const hex = await sha256Hex(`${state.serverSeed}-${state.clientSeed}-${state.nonce}-${index}`);
          // split in 8-hex (32-bit) blocks
          for (let off = 0; off + 8 <= hex.length && floats.length < count; off += 8) {
            const block = hex.slice(off, off+8);
            const num = parseInt(block, 16) >>> 0;
            floats.push((num) / 0x100000000);
          }
          index++;
        }
        return floats;
      }

      // Binomial coefficient nCk
      function nCk(n, k) {
        if (k < 0 || k > n) return 0;
        if (k === 0 || k === n) return 1;
        k = Math.min(k, n-k);
        let res = 1;
        for (let i=1; i<=k; i++) {
          res = res * (n - k + i) / i;
        }
        return res;
      }
      function binomialProb(n, k) {
        return nCk(n, k) / Math.pow(2, n);
      }

      // Build payout shape and scale to RTP=1-HOUSE_EDGE
      function buildPayouts(rows, risk) {
        const slots = rows + 1;
        const center = rows / 2;
        const params = {
          low:   { a: 1.0, b: 2.5, c: 0.12 },
          medium:{ a: 2.3, b: 2.0, c: 0.22 },
          high:  { a: 7.5, b: 1.6, c: 0.32 },
        }[risk];

        const raw = [];
        for (let i=0; i<slots; i++) {
          const d = Math.abs(i - center) / (rows/2); // 0..1
          let m = 1 + params.a * Math.pow(d, params.b) - params.c * Math.pow(1 - d, 2);
          m = Math.max(0.05, m);
          raw.push(m);
        }

        // Expected value of raw
        let EV = 0;
        for (let i=0; i<slots; i++) EV += binomialProb(rows, i) * raw[i];
        const scale = (1 - HOUSE_EDGE) / EV;

        // Scale and round to 2 dec
        const payouts = raw.map(v => Math.max(0.01, Math.round(v * scale * 100) / 100));
        // Ensure center not below 0.1x
        return payouts;
      }

      // Canvas rendering and animation
      const ctx = el.board.getContext('2d');
      function resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;
        const cssW = el.board.clientWidth;
        const cssH = el.board.clientHeight;
        el.board.width = Math.floor(cssW * dpr);
        el.board.height = Math.floor(cssH * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // scale drawing to CSS pixels
        drawBoard(); // redraw pins and static
      }

      function drawBoard() {
        const w = el.board.clientWidth;
        const h = el.board.clientHeight;
        ctx.clearRect(0, 0, w, h);

        // Draw subtle grid / pins
        const rows = state.rows;
        const paddingX = 24;
        const paddingTop = 24;
        const paddingBottom = 80; // leave space for labels
        const usableW = w - paddingX*2;
        const usableH = h - paddingTop - paddingBottom;

        // pins arranged triangular
        ctx.fillStyle = '#12442d';
        for (let r=0; r<rows; r++) {
          const y = paddingTop + (usableH * (r+1) / (rows+1));
          const count = r + 1;
          const gap = usableW / rows;
          // offset to center the row
          const rowWidth = (count - 1) * gap;
          const startX = paddingX + (usableW - rowWidth)/2;
          for (let i=0; i<count; i++) {
            const x = startX + i*gap;
            ctx.beginPath();
            ctx.arc(x, y, 3, 0, Math.PI*2);
            ctx.fill();
          }
        }

        // Draw side walls
        ctx.strokeStyle = '#1e5a3c';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(paddingX, paddingTop);
        ctx.lineTo(paddingX, h - paddingBottom + 8);
        ctx.moveTo(w - paddingX, paddingTop);
        ctx.lineTo(w - paddingX, h - paddingBottom + 8);
        ctx.stroke();

        // Draw slots separators
        const slots = rows + 1;
        const gap = usableW / rows;
        const baseY = h - paddingBottom + 10;
        ctx.strokeStyle = '#0f3b27';
        ctx.lineWidth = 1;
        for (let s=0; s<=rows; s++) {
          const x = paddingX + s*gap;
          ctx.beginPath();
          ctx.moveTo(x, baseY);
          ctx.lineTo(x, baseY + 40);
          ctx.stroke();
        }

        // Draw slot bases
        ctx.fillStyle = '#0b2519';
        ctx.fillRect(paddingX, baseY + 40, usableW, 8);
      }

      function renderPayoutLabels() {
        const rows = state.rows;
        const slots = rows + 1;
        el.payouts.innerHTML = '';
        for (let i=0; i<slots; i++) {
          const d = document.createElement('div');
          d.className = 'payout';
          const v = state.payouts[i];
          d.innerHTML = `<span class="x">${v.toFixed(2)}x</span>`;
          el.payouts.appendChild(d);
        }
      }

      function updateTopline() {
        el.balance.textContent = fmt(state.balance, 0);
        el.playsLeft.textContent = state.playsLeft;
        el.wins.textContent = state.wins;
        el.losses.textContent = state.losses;
        el.serverSeed.textContent = state.serverSeed;
        el.clientSeed.textContent = state.clientSeed;
        el.nonce.textContent = state.nonce;
        el.nonce2.textContent = state.nonce;
        el.rtp.textContent = (100*(1 - HOUSE_EDGE)).toFixed(2) + '%';

        const bet = clampBet();
        el.dropBtn.disabled = state.dropping || state.playsLeft <= 0 || bet > state.balance;
      }

      function recalcPayouts() {
        const rows = parseInt(el.rows.value, 10);
        const risk = el.risk.value;
        state.rows = rows;
        state.risk = risk;
        state.payouts = buildPayouts(rows, risk);
        renderPayoutLabels();
        drawBoard();
        save();
        updateTopline();
      }

      function addHistory(entry) {
        const tr = document.createElement('tr');
        tr.className = entry.win ? 'win' : 'lose';
        tr.innerHTML = `
          <td>${entry.time}</td>
          <td>${fmt(entry.bet, 0)}</td>
          <td>${entry.risk}</td>
          <td>${entry.rows}</td>
          <td>${entry.slot}/${entry.slots-1}</td>
          <td>${entry.mult.toFixed(2)}x</td>
          <td>${entry.win ? '+'+fmt(entry.payout, 2) : '-'+fmt(entry.bet, 2)}</td>
          <td>${fmt(entry.balance, 0)}</td>
        `;
        el.historyBody.prepend(tr);
      }

      // Animation of one drop using deterministic bits
      async function animateDropAndResolve() {
        state.dropping = true;
        updateTopline();

        const bet = clampBet();
        const rows = state.rows;
        const slots = rows + 1;

        // advance nonce BEFORE RNG (so this drop is nonce N)
        state.nonce += 1;
        updateTopline();

        // Fetch deterministic random floats for steps
        const rnds = await fairFloats(rows + 12); // some extra for jitter
        let rights = 0;
        const steps = [];

        // Build the actual left/right path using first 'rows' randoms
        for (let s=0; s<rows; s++) {
          const r = rnds[s];
          const moveRight = r >= 0.5;
          if (moveRight) rights += 1;
          steps.push(moveRight ? 1 : 0);
        }
        const finalSlot = rights;
        const mult = state.payouts[finalSlot];

        // Animation path: top to bottom, gradually steer to target x with jitter
        await animateBall(steps, finalSlot, rnds.slice(rows));

        // Resolve payout
        let delta = -bet;
        let win = false;
        if (mult > 0) {
          const payout = bet * mult;
          delta = -bet + payout;
          win = mult > 1.0;
        }
        state.balance = Math.max(0, state.balance + delta);
        state.playsLeft = Math.max(0, state.playsLeft - 1);
        if (win) state.wins += 1; else state.losses += 1;

        addHistory({
          time: nowTime(),
          bet,
          risk: state.risk,
          rows,
          slot: finalSlot,
          slots,
          mult,
          win,
          payout: mult * bet,
          balance: state.balance
        });

        save();
        updateTopline();
        state.dropping = false;
        updateTopline();
      }

      async function animateBall(steps, finalSlot, jitterRnds) {
        const w = el.board.clientWidth;
        const h = el.board.clientHeight;

        // Geometry
        const paddingX = 24;
        const paddingTop = 12;
        const paddingBottom = 80;
        const usableW = w - paddingX*2;
        const usableH = h - paddingTop - paddingBottom;
        const rows = state.rows;
        const gap = usableW / rows;

        // Target X (slot center at base)
        const baseY = h - paddingBottom + 30;
        const targetX = paddingX + finalSlot * gap;

        // Starting position (top-center)
        let x = paddingX + (usableW/2);
        let y = paddingTop + 4;

        // Draw frame helper
        function drawFrame(x, y) {
          drawBoard();
          // ball
          const grd = ctx.createRadialGradient(x, y, 2, x, y, 10);
          grd.addColorStop(0, '#39ff14');
          grd.addColorStop(1, '#0c2d20');
          ctx.fillStyle = grd;
          ctx.beginPath();
          ctx.arc(x, y, 8, 0, Math.PI*2);
          ctx.fill();

          // highlight target slot
          ctx.fillStyle = '#1e5a3c55';
          ctx.fillRect(paddingX + finalSlot*gap - gap/2 + 1, baseY-2, gap-2, 44);
        }

        // Animate step-by-step downwards
        const totalSteps = rows;
        for (let s=0; s<totalSteps; s++) {
          const stepY = paddingTop + (usableH * (s+1) / (rows+1));
          // Desired x after this step approximates the current partial slot center
          // partial rights up to s
          const rightsSoFar = steps.slice(0, s+1).reduce((a,b)=>a+b,0);
          const partialX = paddingX + rightsSoFar * gap;

          const frames = 12; // frames per row step
          for (let f=0; f<frames; f++) {
            const t = (f+1)/frames;
            // interpolate y
            const newY = y + (stepY - y) * t;
            // steer x towards partialX with some easing
            let steer = x + (partialX - x) * (0.25 + 0.75*t);
            // jitter for "bounce" using extra randomness
            const j = jitterRnds[(s*frames+f) % jitterRnds.length] || 0.3;
            const jitter = (j - 0.5) * 6; // +/-3 px
            const newX = Math.max(paddingX, Math.min(paddingX + usableW, steer + jitter));

            drawFrame(newX, newY);
            await new Promise(r => requestAnimationFrame(r));
          }
          x = paddingX + rightsSoFar * gap;
          y = stepY;
          drawFrame(x, y);
          await new Promise(r => requestAnimationFrame(r));
        }

        // Final fall to base line near slot
        const finalY = baseY - 8;
        const frames = 14;
        for (let f=0; f<frames; f++) {
          const t = (f+1)/frames;
          const newY = y + (finalY - y) * t;
          const newX = x + (targetX - x) * t;
          drawFrame(newX, newY);
          await new Promise(r => requestAnimationFrame(r));
        }
        drawFrame(targetX, finalY);
        await new Promise(r => requestAnimationFrame(r));
      }

      async function doDrop() {
        if (state.dropping) return;
        const bet = clampBet();
        if (bet > state.balance || bet < 1) { updateTopline(); return; }
        if (state.playsLeft <= 0) { updateTopline(); return; }
        await animateDropAndResolve();
      }

      function toggleAuto() {
        state.auto = !state.auto;
        el.autoBtn.textContent = `Auto-drop: ${state.auto ? 'ON' : 'OFF'}`;
        el.autoBtn.dataset.running = state.auto ? '1' : '0';
        if (state.auto) {
          const loop = async () => {
            if (!state.auto) return;
            if (state.playsLeft <= 0 || clampBet() > state.balance) {
              state.auto = false;
              el.autoBtn.textContent = 'Auto-drop: OFF';
              return;
            }
            await doDrop();
            setTimeout(loop, 600);
          };
          loop();
        }
      }

      function resetDemo() {
        state.balance = 1000;
        state.playsLeft = 50;
        state.wins = 0;
        state.losses = 0;
        state.nonce = 0;
        el.historyBody.innerHTML = '';
        save();
        updateTopline();
        drawBoard();
      }

      // Event listeners
      window.addEventListener('resize', resizeCanvas);
      el.bet.addEventListener('input', updateTopline);
      el.risk.addEventListener('change', recalcPayouts);
      el.rows.addEventListener('change', recalcPayouts);
      el.dropBtn.addEventListener('click', doDrop);
      el.autoBtn.addEventListener('click', toggleAuto);
      el.resetBtn.addEventListener('click', resetDemo);
      document.querySelectorAll('.chip').forEach(ch => {
        ch.addEventListener('click', () => {
          let v = parseInt(el.bet.value || '0', 10);
          if (ch.dataset.add) v += parseInt(ch.dataset.add, 10);
          if (ch.dataset.mul) v = Math.ceil(v * parseFloat(ch.dataset.mul));
          if (ch.dataset.half) v = Math.max(1, Math.floor(v/2));
          if (ch.dataset.max) v = Math.max(1, Math.floor(state.balance));
          el.bet.value = String(v);
          updateTopline();
        });
      });
      el.regenClient.addEventListener('click', () => {
        state.clientSeed = genClientSeed();
        state.nonce = 0;
        save();
        updateTopline();
      });

      // Init
      load();
      resizeCanvas();
      recalcPayouts();
      updateTopline();
    })();
  </script>
</body>
</html>
