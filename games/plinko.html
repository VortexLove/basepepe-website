<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"/>
  <title>Pepe Plinko - PBJ Casino</title>

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Press+Start+2P&display=swap" rel="stylesheet" />

  <!-- Frameworks -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Physics Engine -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  <!-- Effects -->
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>

  <style>
    :root {
      --neon-green: #39ff14;
      --panel-bg: rgba(5, 10, 8, 0.95);
      --glass-border: rgba(57, 255, 20, 0.2);
    }

    body { font-family: 'Inter', sans-serif; background-color: #020202; color: #e0e0e0; overflow: hidden; touch-action: none; }
    .pixel-font { font-family: 'Press Start 2P', cursive; }

    /* Background */
    body::before {
      content: ""; position: fixed; inset: 0; pointer-events: none; z-index: -2;
      background: radial-gradient(circle at 50% 10%, rgba(34, 197, 94, 0.08), transparent 60%);
    }
    
    /* Glass Panels */
    .glass-panel {
      background: var(--panel-bg);
      backdrop-filter: blur(12px);
      border: 1px solid var(--glass-border);
      border-radius: 16px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8);
    }

    /* Game Container */
    #game-wrapper {
      position: relative;
      width: 100%;
      max-width: 600px;
      margin: 0 auto;
      height: 70vh; /* Mobile optimized */
      overflow: hidden;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    /* Multiplier Buckets (HTML overlay on top of canvas) */
    .bucket-row {
      position: absolute;
      bottom: 20px;
      left: 0;
      width: 100%;
      display: flex;
      justify-content: space-between;
      padding: 0 10px;
      pointer-events: none;
    }

    .bucket {
      flex: 1;
      margin: 0 2px;
      height: 30px;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 8px;
      font-weight: bold;
      color: rgba(0,0,0,0.8);
      box-shadow: 0 2px 5px rgba(0,0,0,0.5);
      transition: transform 0.1s, filter 0.1s;
    }
    
    .bucket.hit {
      transform: scale(1.2) translateY(-5px);
      filter: brightness(1.5);
      z-index: 10;
      color: white;
      text-shadow: 0 0 5px black;
    }

    /* Gradients for risk levels */
    .b-low { background: #3b82f6; }
    .b-med { background: #a855f7; }
    .b-high { background: linear-gradient(180deg, #ef4444, #b91c1c); }
    .b-center { background: #eab308; }

    /* Button Animation */
    .action-btn {
      background: linear-gradient(135deg, #22c55e 0%, #15803d 100%);
      box-shadow: 0 4px 0 #064e3b;
      transition: all 0.1s;
    }
    .action-btn:active { transform: translateY(4px); box-shadow: 0 0 0 transparent; }

    /* Toast */
    .toast {
      position: fixed; top: 80px; right: 20px;
      background: rgba(0,0,0,0.9); border-left: 4px solid var(--neon-green); color: white;
      padding: 12px 20px; border-radius: 4px; font-size: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.5);
      opacity: 0; pointer-events: none; transition: opacity 0.3s; transform: translateX(20px);
    }
    .toast.show { opacity: 1; transform: translateX(0); }
    
    /* Floating Win Text */
    .float-win {
      position: absolute;
      font-weight: bold;
      color: #39ff14;
      text-shadow: 0 2px 0 black;
      pointer-events: none;
      animation: floatUp 1s ease-out forwards;
      font-size: 12px;
      z-index: 50;
    }
    @keyframes floatUp {
      0% { opacity: 1; transform: translateY(0) scale(1); }
      100% { opacity: 0; transform: translateY(-50px) scale(1.5); }
    }
  </style>
</head>
<body class="flex flex-col h-screen">

  <!-- Header -->
  <nav class="bg-black/90 border-b border-white/10 p-3 flex justify-between items-center z-50">
    <div class="flex items-center gap-2">
      <a href="../index.html" class="text-gray-400 hover:text-white text-xs pixel-font">← BACK</a>
      <span class="text-green-400 pixel-font ml-2 text-xs md:text-sm">PLINKO</span>
    </div>
    <div class="flex items-center gap-4">
      <div class="bg-green-900/20 border border-green-800 px-3 py-1 rounded-full text-xs text-green-400 flex items-center gap-2">
        <span>$PBJ</span>
        <span id="balance" class="font-mono font-bold">10,000</span>
      </div>
    </div>
  </nav>

  <!-- Game Area -->
  <div id="game-wrapper" class="flex-grow bg-black/50">
    <!-- The Canvas is injected here by Matter.js -->
    
    <!-- HTML Overlay for Buckets (Easier to style than Canvas) -->
    <div id="buckets-container" class="bucket-row">
      <!-- Generated via JS -->
    </div>
  </div>

  <!-- Controls -->
  <div class="bg-black border-t border-white/10 p-4 pb-8 z-50">
    <div class="max-w-2xl mx-auto glass-panel p-4 flex flex-col md:flex-row gap-4 items-center justify-between">
      
      <!-- Bet Input -->
      <div class="w-full md:w-auto flex items-center gap-2">
        <div class="bg-gray-900 border border-gray-700 rounded-lg flex items-center p-1">
          <span class="text-xs text-gray-500 px-2">BET</span>
          <input type="number" id="betAmount" value="100" class="bg-transparent text-white w-20 outline-none font-mono text-sm" />
        </div>
        <div class="flex gap-1">
           <button onclick="adjustBet(0.5)" class="bg-gray-800 text-xs px-2 py-2 rounded hover:bg-gray-700">½</button>
           <button onclick="adjustBet(2)" class="bg-gray-800 text-xs px-2 py-2 rounded hover:bg-gray-700">2x</button>
        </div>
      </div>

      <!-- Info -->
      <div class="text-xs text-gray-400 hidden md:block">
        Rows: <span class="text-white">16</span> | Risk: <span class="text-red-400">High</span>
      </div>

      <!-- Play Button -->
      <button id="dropBtn" class="w-full md:w-48 action-btn text-white font-bold py-3 rounded-lg pixel-font text-sm tracking-wider">
        DROP BALL
      </button>

    </div>
  </div>

  <div id="toast" class="toast">Win!</div>

  <script>
    // === CONFIG ===
    const ENGINE_CONFIG = {
      width: 600,
      height: 800,
      pins: 16, // Rows
      pinSize: 4,
      ballSize: 6,
    };

    // Multipliers (High Risk - 16 Rows)
    // Center is index 8/9 approx.
    const MULTIPLIERS = [1000, 130, 26, 9, 4, 2, 0.2, 0.2, 0.2, 0.2, 0.2, 2, 4, 9, 26, 130, 1000];
    
    // Matter.js Aliases
    const Engine = Matter.Engine,
          Render = Matter.Render,
          Runner = Matter.Runner,
          Bodies = Matter.Bodies,
          Composite = Matter.Composite,
          Events = Matter.Events,
          Body = Matter.Body;

    let engine, render, runner;
    let balance = 10000;
    let isMuted = false;

    // === INITIALIZATION ===
    function initGame() {
      // Create Engine
      engine = Engine.create();
      // Slightly reduce gravity for "floaty" Plinko feel
      engine.world.gravity.y = 1.2; 

      // Create Renderer
      const wrapper = document.getElementById('game-wrapper');
      render = Render.create({
        element: wrapper,
        engine: engine,
        options: {
          width: wrapper.clientWidth,
          height: wrapper.clientHeight,
          wireframes: false,
          background: 'transparent',
          pixelRatio: window.devicePixelRatio // Sharpness on mobile
        }
      });

      // Build World
      createPins();
      createWalls();
      generateBucketUI();

      // Run
      Render.run(render);
      runner = Runner.create();
      Runner.run(runner, engine);

      // Collision Event (for scoring)
      Events.on(engine, 'collisionStart', handleCollisions);
      
      // Loop to clean up balls that fall off screen (safety net)
      Events.on(engine, 'beforeUpdate', () => {
        const bodies = Composite.allBodies(engine.world);
        bodies.forEach(body => {
          if (body.label === 'ball' && body.position.y > wrapper.clientHeight + 100) {
            Composite.remove(engine.world, body);
          }
        });
      });

      // Handle Resize
      window.addEventListener('resize', () => {
        render.canvas.width = wrapper.clientWidth;
        render.canvas.height = wrapper.clientHeight;
        // In a real prod app, you'd need to scale bodies positions here.
        // For this demo, we keep it simple (might require refresh on heavy resize).
      });
    }

    // === WORLD BUILDING ===
    function createPins() {
      const worldWidth = document.getElementById('game-wrapper').clientWidth;
      const startY = 100; // Top margin
      const spacing = worldWidth / (ENGINE_CONFIG.pins + 1); // Dynamic spacing based on width

      for (let row = 0; row < ENGINE_CONFIG.pins; row++) {
        const pinsInRow = row + 3; // Pyramid shape
        const y = startY + row * (spacing * 0.9); // Vertical spacing
        
        for (let col = 0; col < pinsInRow; col++) {
          // Center offset math
          const x = (worldWidth / 2) - ((pinsInRow - 1) * spacing / 2) + (col * spacing);
          
          const pin = Bodies.circle(x, y, ENGINE_CONFIG.pinSize, {
            isStatic: true,
            label: 'pin',
            render: { fillStyle: '#fff', shadowBlur: 5, shadowColor: '#fff' },
            restitution: 0.5
          });
          Composite.add(engine.world, pin);
        }
      }
    }

    function createWalls() {
        // Invisible walls to funnel balls if they go too wide (unlikely but good safety)
        // Not strictly necessary if physics are tuned right, keeping it clean.
    }

    function generateBucketUI() {
      const container = document.getElementById('buckets-container');
      container.innerHTML = '';
      
      MULTIPLIERS.forEach((mult, index) => {
        const div = document.createElement('div');
        div.className = 'bucket';
        div.textContent = mult + 'x';
        div.id = `bucket-${index}`;
        
        // Color coding
        if(mult >= 100) div.classList.add('b-high');
        else if(mult >= 10) div.classList.add('b-med');
        else if(mult >= 2) div.classList.add('b-low');
        else div.classList.add('b-center');
        
        container.appendChild(div);
      });

      // Add invisible sensors in Matter.js world at the bottom
      const worldWidth = document.getElementById('game-wrapper').clientWidth;
      const bucketWidth = worldWidth / MULTIPLIERS.length;
      const yPos = document.getElementById('game-wrapper').clientHeight - 15; // Near bottom

      MULTIPLIERS.forEach((mult, i) => {
         const x = (i * bucketWidth) + (bucketWidth/2);
         const sensor = Bodies.rectangle(x, yPos, bucketWidth, 10, {
             isStatic: true,
             isSensor: true, // Ball passes through but triggers event
             label: `sensor-${i}-${mult}`,
             render: { visible: false }
         });
         Composite.add(engine.world, sensor);
      });
    }

    // === GAMEPLAY ===
    document.getElementById('dropBtn').addEventListener('click', dropBall);

    function adjustBet(factor) {
       const input = document.getElementById('betAmount');
       let val = parseInt(input.value);
       val = Math.floor(val * factor);
       if(val < 10) val = 10;
       input.value = val;
    }

    function dropBall() {
       const bet = parseInt(document.getElementById('betAmount').value);
       if(balance < bet) {
           showToast("Insufficient Funds!", "error");
           return;
       }

       // Update Balance
       balance -= bet;
       updateUI();

       // Spawn Ball Logic
       const worldWidth = document.getElementById('game-wrapper').clientWidth;
       const xStart = (worldWidth / 2) + (Math.random() * 4 - 2); // Tiny random offset to prevent stacking
       
       const ball = Bodies.circle(xStart, 20, ENGINE_CONFIG.ballSize, {
           restitution: 0.8, // Bouncy
           friction: 0.001,
           frictionAir: 0.02, // Air resistance controls terminal velocity
           label: 'ball',
           betAmount: bet, // Attach bet data to the physics body
           render: { 
               fillStyle: '#39ff14',
               strokeStyle: '#fff',
               lineWidth: 1
           },
           collisionFilter: {
               group: -1 // Negative group means balls don't collide with EACH OTHER, only pins
           }
       });
       
       // Add slight initial velocity
       Body.setVelocity(ball, { x: (Math.random() - 0.5), y: 0 });

       Composite.add(engine.world, ball);
    }

    // === SCORING ===
    function handleCollisions(event) {
        const pairs = event.pairs;
        
        pairs.forEach(pair => {
            const bodyA = pair.bodyA;
            const bodyB = pair.bodyB;
            
            // Identify ball and sensor
            let ball, sensor;
            if (bodyA.label === 'ball' && bodyB.label.startsWith('sensor')) { ball = bodyA; sensor = bodyB; }
            else if (bodyB.label === 'ball' && bodyA.label.startsWith('sensor')) { ball = bodyB; sensor = bodyA; }
            
            if (ball && sensor) {
                // Logic to only process once
                if(ball.isProcessed) return;
                ball.isProcessed = true;

                // Parse sensor data: sensor-{index}-{multiplier}
                const parts = sensor.label.split('-');
                const index = parseInt(parts[1]);
                const mult = parseFloat(parts[2]);
                
                const bet = ball.betAmount;
                const payout = bet * mult;
                
                balance += payout;
                updateUI();
                
                // Visuals
                animateBucket(index);
                showFloatText(payout, sensor.position.x, sensor.position.y);
                
                if(mult >= 10) {
                    showToast(`BIG WIN! ${mult}x`, "success");
                    confetti({ particleCount: 50, spread: 60, origin: { y: 0.8 } });
                }

                // Remove ball shortly after (allow it to fall through the screen)
                setTimeout(() => {
                    Composite.remove(engine.world, ball);
                }, 100);
            }
            
            // Sound effect on Pin hit (Optional)
            if ((bodyA.label === 'ball' && bodyB.label === 'pin') || (bodyB.label === 'ball' && bodyA.label === 'pin')) {
               // playSound(); // Implementation optional
            }
        });
    }

    // === VISUALS & UI ===
    function updateUI() {
        document.getElementById('balance').textContent = Math.floor(balance).toLocaleString();
    }

    function animateBucket(index) {
        const el = document.getElementById(`bucket-${index}`);
        if(el) {
            el.classList.add('hit');
            setTimeout(() => el.classList.remove('hit'), 200);
        }
    }

    function showFloatText(amount, x, y) {
        const wrapper = document.getElementById('game-wrapper');
        const el = document.createElement('div');
        el.className = 'float-win';
        el.textContent = `+${Math.floor(amount)}`;
        el.style.left = x + 'px';
        el.style.top = (y - 40) + 'px'; // Offset slightly up
        wrapper.appendChild(el);
        setTimeout(() => el.remove(), 1000);
    }

    function showToast(msg, type="neutral") {
        const t = document.getElementById('toast');
        t.textContent = msg;
        t.style.borderColor = type === "error" ? "#ef4444" : "#39ff14";
        t.classList.add('show');
        setTimeout(() => t.classList.remove('show'), 2000);
    }

    // Run
    window.onload = initGame;

  </script>
</body>
</html>
